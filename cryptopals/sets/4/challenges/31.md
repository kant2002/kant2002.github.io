---
layout: cryptopals
title: Крипточуваки - 31
permalink: /cryptopals/sets/4/challenges/31
---

# Реалізувати та зламати HMAC-SHA1 за допомогою штучного витоку часу

Псевдокоду у Вікіпедії має бути достатньо. HMAC дуже простий.

Використовуючи веб-фреймворк за вашим вибором (Sinatra, web.py тощо), напишіть маленьку програму, яка має URL-адресу, яка приймає аргумент «file» і аргумент «signature», наприклад:

```
http://localhost:9000/test?file=foo&signature=46b4ec586117154dacd49d664e5d63fdc88efb51
```

Попросіть сервер згенерувати ключ HMAC, а потім переконайтеся, що «підпис» у вхідних запитах дійсний для «file», використовуючи оператор «==», щоб порівняти дійсний MAC для файлу з параметром «signature» (іншими словами, перевірте HMAC так, як це перевірить будь-який звичайний програміст).

Напишіть функцію, назвіть її "insecure_compare", яка реалізує операцію ==, виконуючи порівняння байтів за раз із раннім виходом (тобто повертаючи false у першому невідповідному байті).

У циклі для "insecure_compare" додайте 50 мс сну (сон 50 мс після кожного байта).

Використовуйте свою функцію "insecure_compare", щоб перевірити HMAC у вхідних запитах і перевірити, чи працює вся штука. Поверніть 500, якщо MAC недійсний, і 200, якщо він нормальний.

Використовуючи витік часу в цій програмі, напишіть програму, яка виявляє дійсний MAC для будь-якого файлу.

<div class="panel panel-warning">
  <div class="panel-heading">
    <h3 class="panel-title">Чому штучні затримки?</h3>
  </div>
  <div class="panel-body">
    <p>
      Порівняння рядків із раннім виходом є, ймовірно, найпоширенішим джерелом витоків криптографічного часу, але їх не дуже легко використовувати. Фактично, багато витоків синхронізації (наприклад, будь-які в C, C++, Ruby або Python), ймовірно, взагалі не можна використовувати в глобальній мережі. Щоб грати з атакуючими витоками синхронізації в реальному світі, вам потрібно почати писати низькорівневий код праці із часом. У цих викликах ми зберігаємо криптографічні засоби.
    </p>
  </div>
</div>