---
layout: post
title:  "Шаблони використання LLM - Шаблон нескінченної генерації"
date:   2025-06-28 13:36:21 +0500
categories: LLM
comments: true
---

Це сьома стаття стаття із серії яка описує шаблони будування запитів до LLM систем.
Інші статті в серії
- [1. Шаблон створення сленгу]({% post_url 2025-02-02-llm-patterns %})
- [2. Автоматизатор виводу]({% post_url 2025-02-21-output-automater %})
- [3. Перевернута взаємодія]({% post_url 2025-03-06-flipped-interaction %})
- [4. Шаблон персона]({% post_url 2025-03-31-persona-pattern %})
- [5. Шаблон уточнення питання]({% post_url 2025-05-25-alternative-approach %})
- [6. Шаблон альтернативні підходи]({% post_url 2025-05-25-alternative-approach %})
- [7. Шаблон когнітивного верифікатора]({% post_url 2025-06-14-cognitive-verifier %})
- [8. Шаблон список фактів для перевірки]({% post_url 2025-06-21-fact-checker-list %})

# Шаблон нескінченної генерації

## Намір і контекст

Мета цього шаблону полягає в автоматичній генерації серії результатів (які можуть здаватися нескінченними) без необхідності кожного разу повторно вводити запит генератора. Мета полягає в тому, щоб обмежити обсяг тексту, який користувач повинен ввести для отримання наступного виводу, виходячи з припущення, що користувач не хоче постійно повторно вводити запит. У деяких варіаціях метою є дозволити користувачеві зберегти початковий шаблон запиту, але додати до нього додаткові варіації шляхом додаткових уточнень перед кожним згенерованим виводом.

## Мотивація

Багато завдань вимагають повторного застосування одного й того ж запиту для багатьох концепцій. Наприклад, генерація коду для операцій створення, читання, оновлення та видалення (CRUD) для певного типу сутності може вимагати застосування одного й того ж запиту до кількох типів сутностей. Якщо користувач змушений повторно вводити запит знову і знову, він може припуститися помилок. *Шаблон нескінченної генерації* дозволяє користувачеві повторно застосовувати запит, з подальшим введенням або без нього, для автоматизації генерації кількох виходів за допомогою заздалегідь визначеного набору обмежень.

<!--more-->

## Структура та ключові ідеї

Основні твердження для контексту:

> Я хотів би, щоб ви генерували вихідні дані вічно, X результат за раз.

> (Необов'язково) ось як використовувати вхідні дані, які я надаю між виходами.

> (Необов'язково) зупиняйтеся, коли я вас про це попрошу.

Перше твердження вказує, що користувач хоче, щоб LLM генерував вивід необмежений час, що фактично передає інформацію про те, що одне й те саме запрошення буде використовуватися знову і знову. Вказуючи кількість результатів, які мають бути згенеровані одночасно (тобто «X результатів одночасно»), користувач може обмежити швидкість генерації, що може бути особливо важливим, якщо існує ризик того, що вивід перевищить обмеження довжини для одного результату, встановлені LLM.

Другий оператор надає додаткові інструкції щодо використання вхідних даних, наданих користувачем, між результатами. Вказуючи, як можна надавати та використовувати додаткові вхідні дані користувача між підказками, користувач може створити стратегію підказок, яка використовує відгук користувача в контексті початкової підказки. Початкова підказка все ще знаходиться в контексті генерації, але кожен вхідний дані користувача між кроками генерації включається в початкову підказку для уточнення результату за допомогою заданих правил.

Третій оператор надає користувачеві додатковий спосіб зупинити процес генерації виводу. Цей крок не завжди потрібен, але може бути корисним у ситуаціях, коли може виникнути неоднозначність щодо того, чи призначені користувачем вхідні дані для уточнення наступної генерації, чи команда зупинки. Наприклад, можна створити явну фразу зупинки, якщо користувач генерував дані, пов'язані з дорожніми знаками, і користувач може захотіти ввести уточнення генерації, наприклад, «стоп», щоб вказати, що до виводу результату треба додати слово зупинки.

## Приклад реалізації

Нижче наведено приклад нескінченної генерації запиту для створення серії URL-адрес:

>  «Відтепер я хочу, щоб ти генерувала ім'я та посаду, доки я не скажу стоп. Я надаю шаблон для твого результату. Усе, що написано великими літерами, є тимчасовим заповнювачем у шаблоні. Щоразу, коли ви генеруєте текст, намагайтеся вмістити його в один із тимчасових заповнювачів, які я перелічу. Будь ласка, збережіть форматування та загальний шаблон, які я надаю: https://myapi.com/NAME/profile/JOB».

Цей запит поєднує функціональність шаблону *Нескінченна генерація* та шаблону *Шаблон*. Користувач робить запит, щоб LLM безперервно генерував ім'я та посаду, доки не буде чітко наказано «стоп». Згенеровані результати потім форматуються у наданий шаблон, який містить заповнювачі для імені та посади. Використовуючи шаблон *Нескінченна генерація*, користувач отримує кілька результатів без необхідності постійно повторно вводити шаблон. Аналогічно, *Шаблон* застосовується для забезпечення узгодженого формату результатів.

## Наслідки

У розмовних LLM вхідними даними для моделі на кожному кроці часу є попередній вихідний сигнал та новий вхідний сигнал користувача. Хоча деталі того, що зберігається та повторно вводиться в наступному циклі результатів, залежать від моделі та реалізації, вони часто обмежені за обсягом. Тому модель постійно отримує попередні вихідні сигнали та підказку, що може призвести до того, що модель з часом втратить відстеження оригінальних інструкцій підказки, якщо вони перевищують обсяг того, що надається як вхідні дані.

Оскільки генеруються додаткові виходи, контекст навколо підказки може зникати, що призводить до відхилення моделі від запланованої поведінки. Важливо контролювати виходи, що генеруються моделлю, щоб (1) переконатися, що вона все ще дотримується бажаної поведінки, та (2) надавати коригувальний зворотний зв'язок, якщо необхідно. Ще одне питання, яке слід враховувати, полягає в тому, що LLM може генерувати повторювані виходи, що може бути небажаним, оскільки користувачі вважають це повторення виснажливим та схильним до помилок в обробці.