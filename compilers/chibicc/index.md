---
layout: page
title: Вступ у створення компілятора C для тих, хто хоче знати про низькорівневі речі
permalink: /compilers/chibicc
translation_source: https://www.ocf.berkeley.edu/~stefan/fun/chibicc.html
---

Rui Ueyama <ruiu@cs.stanford.edu>

2020-03-16

- [Вступ](#вступ)
  - [Умовні позначення, використані в цій книзі](#умовні-позначення-використані-в-цій-книзі)
  - [Середовище розробки передбачається в цій книзі](#середовище-розробки-передбачається-в-цій-книзі)
  - [Про автора](#про-автора)
- [Машинна мова та асемблер](#машинна-мова-та-асемблер)
  - [ЦП і пам'ять](#цп-і-память)
  - [Що таке асемблер?](#що-таке-асемблер)
  - [C та відповідна асемблерна програма](#c-та-відповідна-асемблерна-програма)
    - [Простий приклад](#простий-приклад)
    - [Приклад із викликом функції](#приклад-із-викликом-функції)
  - [Підсумки цього розділу](#підсумки-цього-розділу)
- Creating a calculator-level language
  - Step 1: Create a language that compiles one integer
  - Step 2: Create a compiler that can add and subtract
  - Step 3: Introduce tokenizer
  - Step 4: Improve error messages
  - Grammar description method and recursive descent parsing
    - Representation of grammatical structure using tree structure
    - Defining grammar using production rules
    - Description of production rules using BNF
    - simple production rules
    - Expressing operator precedence using production rules
    - Productions involving recursion
    - recursive descending parsing
  - stack machine
    - Stack machine concept
    - Compile to stack machine
    - How to create a stack machine on x86-64
  - Step 5: Create a language that can perform four arithmetic operations
  - Step 6: Unary plus and unary minus
  - Step 7: Comparison operators
    - Tokenizer changes
    - new grammar
    - Assembly code generation
- Separate compilation and linking
  - What is separate compilation?
    - Separate compilation and its necessity
    - The necessity of header files and their contents
    - link error
    - Declaration and definition of global variables
  - C standard library and archive files
  - Step 8: File splitting and Makefile changes
    - Split files
    - Makefile changes
- Functions and local variables
  - Step 9: One character local variable
    - Variable area on the stack
    - Tokenizer changes
    - Parser changes
    - lvalue and rvalue
    - How to load a value from any address
    - Code generator changes
    - Main function changes
  - Step 10: Multi-character local variables
  - Step 11: return statement
  - 1973 C compiler
  - Step 12: Add control constructs
  - Step 13: Block
  - Step 14: Respond to function calls
  - Step 15: Address the function definition
  - Binary level interface
- Representation of integers in computers
  - unsigned integer
  - signed integer
  - sign extension
  - Reversal of sign
- Pointers and string literals
  - Step 16: Unary &and Unary*
  - Step 17: Eliminate implicit variable definitions and introduce the int keyword
  - Step 18: Introducing pointer types
    - Define a type that represents a pointer
    - Assign to the value pointed to by the pointer
  - Step 19: Implement pointer addition and subtraction
  - Step 20: sizeof operator
  - Step 21: Implement the array
    - Define an array type
    - Implement implicit type conversion from array to pointer
  - Step 22: Implement array subscripting
  - Step 23: Implement global variables
  - Step 24: Implement the character type
  - Step 25: Implement string literals
  - Step 26: Read input from file
  - Step 27: Line and block comments
  - Step 28: Rewrite the test in C
- Program execution image and initialization formula
  - Executable file structure
  - Data segment contents
  - Initialization expression syntax
  - Global variable initialization expression
  - Local variable initialization expression
- After step 29: [Addition required]
- Static and dynamic links
  - static link
- C type syntax
  - Diagram representing the type
  - Notation for representing types
  - How to read C types
    - How to read non-nested types
    - How to read nested types
  - Exercises
- in conclusion
- Appendix 1: x86-64 Instruction Set Cheat Sheet
  - List of integer registers
  - memory access
  - function call
  - conditional branch
  - conditional assignment
  - Integer/logical operations
- Appendix 2: Version control with Git
  - Workflow using Git
  - Points to note when committing
  - Internal structure of Git
- Appendix 3: Creating a development environment using Docker
  - Setup steps
  - Build using containers
  - Add new application to container
- Reference materials
- index

# Вступ

Ця онлайн-книга зараз пишеться. Це не остаточна версія. [форма зворотного зв'язку](https://goo.gl/forms/DWmgm5fChpJ6IEFI3)

Ця книга наповнена вмістом, який занадто багато, щоб включити в одну книгу. У цій книзі ми створимо програму, яка перетворює вихідний код, написаний мовою Сі, на мову асемблера, тобто компілятор Сі. Сам компілятор також розроблено з використанням C. Найближчою метою є можливість самостійного розміщення, тобто компіляції власного вихідного коду за допомогою домашнього компілятора.

У цій книзі я вирішив пояснити різні теми в прогресивній манері, щоб не ускладнювати пояснення компіляторів. Ось чому:

Концептуально компілятори можна розділити на кілька етапів: аналіз, проміжні проходи та генерація коду. Загальний підхід у підручниках полягає в тому, щоб пояснювати кожну тему розділами, але книги з таким підходом, як правило, стають занадто вузькими та глибокими посередині, що ускладнює для читачів слідування.

Крім того, за допомогою методу розробки для створення кожного етапу неможливо запустити компілятор, доки не будуть завершені всі етапи, тому важко помітити, чи є певна помилка у вашому розумінні чи коді, доки весь етап не почне працювати. Недоліком є ​​те, що ви не можете. По-перше, ви насправді не знаєте, якими будуть вхідні дані наступного етапу, доки ви не створите його самі, тому ви насправді не знаєте, що виводити на попередньому етапі. Інша проблема полягає в тому, що важко залишатися мотивованим, оскільки ви не можете скомпілювати жодного коду, поки він не буде завершений.

У цій книзі я вирішив застосувати інший підхід, щоб уникнути цієї пастки. На початку книги ви реалізуєте ``власну мову'' з дуже простою специфікацією мови. Мова настільки проста, що вам не потрібно багато знати про те, як написати компілятор для її реалізації. Після цього читач продовжуватиме додавати функції до «власної мови» за допомогою цієї книги, і зрештою розвине її до чогось, що сумісно з C.

У такому методі інкрементальної розробки ви створюєте компілятор крок за кроком, роблячи невеликі коміти. За допомогою цього методу розробки компілятор завжди в якомусь сенсі «завершений» при кожному коміті. На одному етапі це може бути лише рівень калькулятора, на іншому це може бути дуже обмежена підмножина C, а на іншому це може бути мова, яку майже можна назвати C. Справа в тому, що на кожному етапі ми прагнемо до мови з прийнятними специфікаціями, які відповідають рівню завершеності на цьому етапі. Під час розробки ми не наголошуємо лише на деяких функціях, щоб це виглядало як мова C.

Ми також пояснимо структури даних, алгоритми та знання з інформатики поетапно відповідно до стадії розробки.

Поступовий розвиток досягає мети, щоб у будь-який момент часу під час читання цієї книги читач мав повне знання про те, як створити розумну мову на цьому рівні. Це набагато краще, ніж стан, коли лише деякі теми створення компілятора надзвичайно детальні. До того часу, коли ви закінчите читати цю книгу, ви будете добре обізнані з усіма темами.

Ця книга також пояснює, як писати великі програми з нуля. Уміння створювати великі програми — унікальне вміння, яке відрізняється від вивчення структур даних і алгоритмів, але я не думаю, що існує багато книг, які пояснюють такі речі. Крім того, навіть якщо хтось пояснить вам це, ви не знатимете, чи є метод розробки хорошим чи поганим, якщо ви не випробували його насправді. Ця книга розроблена таким чином, що процес розробки вашої власної мови на мову C дасть вам практичний досвід хорошого методу розробки.

Якщо план автора вдасться, прочитавши цю книгу, читачі не тільки дізнаються про техніку створення компіляторів і набору інструкцій центрального процесора, а й дізнаються, як розбивати великі програми на маленькі кроки і створювати їх потроху. Ви дізнаєтесь про методи тестування, методи контролю версій і навіть про те, як підготуватися до такого амбітного проекту, як написання компілятора.

Цільова аудиторія цієї книги — звичайні програмісти на C. Вам не потрібно бути суперпрограмістом на C, який добре знає специфікацію мови C. Достатньо, щоб ви розбиралися в покажчиках і масивах і могли принаймні приділити трохи часу читанню невеликих програм C, написаних іншими.

Під час написання цієї книги я намагався не лише пояснити специфікації мови та специфікації процесора, але й якомога докладніше пояснити, чому було обрано саме такий дизайн. Ми також включили колонки про компілятори, центральні процесори, комп’ютерну індустрію та її історію, які зацікавлять читачів і зроблять її читанням приємним.

Створення компілятора - це дуже весело. На початку моя саморобна мова могла робити лише неймовірно прості речі, але, продовжуючи її розвивати, вона швидко стала нагадувати мову C настільки, що навіть я був здивований, і вона почала працювати, наче за помахом чарівної палички. стати. Під час фактичної розробки я часто дивуюся тому, що великий тестовий код, який, на мою думку, не буде добре скомпільований у той час, компілюється без помилок і працює ідеально правильно. Такий код нелегко зрозуміти самому, навіть дивлячись на скомпільовану збірку. Іноді я навіть відчуваю, що мій компілятор має більше розуму, ніж я, автор. Компілятор — це програма, яка, навіть якщо ви знаєте, як вона працює, все одно дивуєтеся, чому вона працює так добре. Я впевнений, що ви теж закохаєтесь у його чарівність.

Отже, без зайвих слів, давайте разом з автором стрибнемо у світ розробки компілятора!

> **Стаття: Чому мова C?**
> 
> Чому серед багатьох доступних мов програмування ви вибрали C для цієї книги? Або чому б не рідна мова? Стосовно цього моменту немає жодних причин, чому це обов’язково має бути C, але якщо вам потрібно вибрати мову, щоб навчитися створювати компілятор, який виводить рідний код, C є розумним вибором, який не дуже поширений. Я думаю, що це один із них.
> 
> Інтерпретовані мови не дозволяють дізнатися багато про нижчі рівні. З іншого боку, C зазвичай компілюється в асемблер, тому, створивши компілятор, ви можете дізнатися про набір інструкцій процесора та роботу програм, а також про сам C.
> 
> C широко використовується, тому, коли у вас є робочий компілятор, ви можете пограти з компіляцією стороннього вихідного коду, який ви завантажуєте з Інтернету. Наприклад, ви можете зібрати та грати в mini Unix xv6. Якщо компілятор достатньо зрілий, можна буде скомпілювати навіть ядро ​​Linux. Така насолода неможлива з другорядними або доморощеними мовами.
> 
> C++ — це статично типізована мова, яка компілюється до рідної машинної мови, як-от C, і використовується принаймні так само широко, як і C. Однак специфікації мови для C++ настільки великі, що неможливо легко створити власний компілятор, тому це нереалістичний варіант.
> 
> Розробка та реалізація оригінальної мови — це добре з точки зору вдосконалення відчуття мовного дизайну, але є й підводні камені. Речі, які важко реалізувати, можна уникнути, уникаючи їх у специфікації мови. Це не стосується таких мов, як C, де специфікація мови дається як стандарт. Я вважаю, що це обмеження досить добре з точки зору навчання.

## Умовні позначення, використані в цій книзі

Функції, вирази, команди тощо відображаються в тексті моноширинним шрифтом, наприклад, `main`, `foo=3`, `make`.

Код, який охоплює кілька рядків, відображається у рамці за допомогою моноширинного шрифту, як показано нижче.

```c
int main() {
  printf("Hello world!\n");
  return 0;
}
```

Якщо рамковий код є командою оболонки, яку користувач має дослівно ввести, рядок $, що починається з, представляє підказку. $Введіть решту цього рядка ($але не решту) в оболонку. $Інші рядки представляють результат введеної вами команди. Наприклад, блок нижче make є прикладом того, що відбувається, коли користувач вводить рядок `make` і натискає Enter. Результатом команди є `make: Nothing to be done for 'all'`:

## Середовище розробки передбачається в цій книзі

У цій книзі передбачається, що 64-розрядне середовище Linux працює на так званому звичайному ПК, такому як Intel або AMD. Будь ласка, інсталюйте інструменти розробки, такі як gcc, і створіть заздалегідь відповідно до дистрибутива, який ви використовуєте. Якщо ви користуєтеся Ubuntu, ви можете встановити команди, які використовуються в цій книзі, виконавши таку команду.

```shell
$ sudo apt update
$ sudo apt install -y gcc make git binutils libc6-dev
```

Хоча macOS досить сумісна з Linux на рівні джерела збірки, вона не є повністю сумісною (зокрема, функція під назвою «статичне зв’язування» не підтримується). Хоча можна створити компілятор C для macOS, використовуючи інформацію з цієї книги, якщо ви спробуєте це, ви, ймовірно, зіткнетеся з низкою незначних несумісностей. Не рекомендується одночасно вивчати прийоми створення компілятора C і відмінності між macOS і Linux. Коли щось не працює, важко зрозуміти, яке розуміння неправильне.

Тому ця книга не стосується macOS. У macOS використовуйте якесь віртуальне середовище, щоб підготувати середовище Linux. Якщо ви вперше готуєте віртуальне середовище Linux, зверніться до [Додатку 3](#), у якому підсумовано, як створити середовище розробки за допомогою Docker.

Windows не сумісна з Linux на рівні джерела складання. Однак у Windows 10 можна запускати Linux у Windows як одну програму, і, використовуючи це, ви можете продовжувати розробку у Windows. Програма під назвою Windows Subsystem for Linux (WSL) є таким Linux-сумісним середовищем. Впроваджуючи вміст цієї книги в Windows, інсталюйте WSL і продовжуйте розробку в ньому.

> **Стаття: крос-компілятор**
> 
> Машина, на якій працює компілятор, називається «хостом», а машина, на якій виконується код, виведений компілятором, називається «цільовою». Хоча в цій книзі обидва є 64-розрядними середовищами Linux, хост і ціль не обов’язково повинні бути однаковими.
> 
> Компілятор, хост і ціль якого відрізняються, називається крос-компілятором. Наприклад, компілятор, який працює в Windows і створює виконуваний файл для Raspberry Pi, є крос-компілятором. Крос-компілятори часто використовуються, коли цільова машина занадто слабка або спеціалізована для запуску компілятора.

## Про автора

Руї Уеяма ( [@rui314](https://twitter.com/rui314) ). Він є оригінальним автором і поточним супроводжувачем високошвидкісного компонувальника lld, який використовується як стандартний компонувальник для створення виконуваних файлів у багатьох ОС і проектах, включаючи Android (версія Q або новіша), FreeBSD (12 або новіша), Nintendo Switch, Chrome і Firefox. (Отже, існує висока ймовірність того, що двійковий файл, створений інструментом, який я написав, уже є на вашому комп’ютері.) Він також є автором компактного компілятора C [8cc](https://github.com/rui314/8cc). В основному я пишу есе про програмне забезпечення в [нотатках](https://note.mu/ruiu).

> **Стаття: компілятор, який компілює компілятор**
> 
> Ситуації з самопосиланням, такі як компілятор C, написаний мовою C, не є рідкістю. Багато реалізацій мови, крім C, написані з використанням самої мови.
> 
> Якщо вже існує реалізація мови X, немає ніяких логічних протиріч у створенні нового компілятора X за допомогою самої мови. Якщо ви вирішите самостійно розміщувати компілятор, ви можете просто розробляти його за допомогою існуючого компілятора, а коли закінчите, переключитися на свій власний. Саме це ми намагаємося зробити в цій книзі.
> 
> Але що, якщо у вас немає наявного компілятора? У такому випадку у вас немає іншого вибору, як писати іншою мовою. Під час написання вашого першого компілятора для мови X з наміром самостійного розміщення вам потрібно буде написати його за допомогою існуючої мови Y, яка відрізняється від X, і коли компілятор буде завершено, вам потрібно буде переписати сам компілятор з мови Y на мову X.
> 
> Компілятори для сучасних складних мов програмування також є іншими компіляторами, які використовувалися для компіляції реалізацій цієї мови, і так далі, поки на початку комп’ютерів хтось не зміг безпосередньо написати машинний код. Ви повинні отримати простий асемблер, який ви написали. Ми не знаємо, чи існував один або кілька асемблерів, які в певному сенсі є основними предками всіх існуючих реалізацій мови, але немає сумніву, що сучасні компілятори починалися з дуже невеликої кількості предків. Шо. Виконувані файли, крім компіляторів, також зазвичай генеруються компіляторами, тому майже всі існуючі виконувані файли є непрямими нащадками вихідного асемблера. Це цікава історія, схожа на походження життя.

---

# Машинна мова та асемблер

Мета цього розділу — дати вам приблизне уявлення про компоненти, з яких складається комп’ютер, і про те, який код ми повинні виводити з компілятора C, який ми створюємо. Ми поки не будемо вдаватися в особливості інструкцій ЦП. По-перше, важливо зрозуміти концепцію.

## ЦП і пам'ять

Компоненти, з яких складається комп’ютер, можна умовно розділити на центральний процесор і пам’ять. Пам'ять - це пристрій, який може зберігати дані, а центральний процесор - це пристрій, який читає та записує цю пам'ять для виконання певної обробки.

Концептуально, пам'ять виглядає для центрального процесора як великий масив байтів, до якого можна отримати довільний доступ. Коли центральний процесор звертається до пам’яті, він визначає, до якого байту пам’яті він хоче отримати доступ, вказуючи число, і це число називається «адресою». Наприклад, «прочитати 8 байт даних з адреси 16» означає зчитування 8 байт даних, починаючи з 16-го байта пам’яті, який виглядає як масив байтів. Те саме можна сказати як «прочитати 8 байт даних з адреси 16».

У пам’яті зберігаються як програми, які виконує ЦП, так і дані, які ці програми читають і записують. Центральний процесор зберігає адресу інструкції, що виконується в даний момент, зчитує інструкцію з цієї адреси, виконує те, що там записано, а потім читає та виконує наступну інструкцію. Адреса інструкції, що виконується в даний момент, називається «Лічильником програми» (PC) або «Покажчиком інструкції» (IP). Фактичний формат програми, яку виконує центральний процесор, називається «машинним кодом».

Лічильник програм не обов'язково лінійно переходить до наступної інструкції. Тип інструкції центрального процесора, який називається «інструкція розгалуження», дозволяє встановити лічильник програм на будь-яку адресу, окрім наступної інструкції. Ця функція дозволяє реалізувати оператори if, цикли тощо. Встановлення лічильника програм у місце, відмінне від наступної інструкції, називається «стрибком» або «розгалуженням».

Крім лічильника програм, центральний процесор також має невелику кількість областей зберігання даних. Наприклад, процесори Intel і AMD мають 16 розташувань, які можуть зберігати 64-розрядні цілі числа. Ця область називається «реєстр». Пам'ять є зовнішнім пристроєм центрального процесора, і для читання та запису в неї потрібен деякий час, але регістри знаходяться всередині центрального процесора, і до них можна отримати доступ без затримки.

Більшість машинних кодів відформатовано таким чином, що деякі операції виконуються з використанням значень двох регістрів, а результат записується назад у регістр. Таким чином, виконання програми передбачає зчитування ЦП даних із пам’яті в регістр, виконання якогось обчислення між регістрами та запис результату назад у пам’ять.

Конкретна інструкція машинної мови разом називається «архітектурою набору інструкцій» (ISA) або «набором інструкцій». Існує не лише один тип набору інструкцій; кожен ЦП може створювати його як завгодно. Однак, оскільки ту саму програму неможливо запустити без сумісності на рівні машинного коду, існує не так багато варіацій у наборах інструкцій. Комп’ютери використовують набір інструкцій під назвою x86-64, розроблений компанією Intel та її виробником сумісних мікросхем AMD. Хоча x86-64 є одним із основних наборів інструкцій, він не домінує на ринку. Наприклад, iPhone і Android використовують набір інструкцій під назвою ARM.

> Стаття: імена набору інструкцій x86-64
> 
> x86-64 також іноді називають AMD64, Intel 64, x64 тощо. Існує історична причина, чому той самий набір інструкцій має кілька таких назв.
> 
> Набір інструкцій x86 був створений Intel у 1978 році, але AMD розширила його до 64-розрядного. Приблизно в 2000 році, коли виникла потреба в 64-розрядних процесорах, Intel була прихильна до абсолютно нового набору інструкцій під назвою Itanium і не потрудилася вирішувати конкуруючу 64-розрядну версію x86. Скориставшись цією можливістю, AMD сформулювала та випустила специфікацію 64-bit x86. Це x86-64. Пізніше AMD перейменувала x86-64 на AMD64, можливо, як стратегію брендингу.
> 
> Після цього провал Itanium став очевидним, і Intel не мала іншого вибору, окрім як створити 64-розрядну версію x86. Однак на той час було випущено досить багато чіпів AMD64, тому було важко розробити розширений набір інструкцій, який був би схожим, але не ідентичним, і Intel вирішила прийняти набір інструкцій, сумісний з AMD. Кажуть, що Microsoft також чинила тиск з метою підтримки сумісності. У той час Intel прийняла набір інструкцій, який був майже ідентичний AMD64, і назвала його IA-32e. Той факт, що його назвали IA-32e (розширення Intel Architecture 32) замість 64, здається, показує тривалу прихильність до невдалого набору інструкцій, оскільки Itanium все ще є основою 64-розрядних процесорів. Тоді Intel вирішила повністю відмовитися від Itanium, і IA-32e було перейменовано на більш традиційну Intel 64. Microsoft називає x86-64 x64, можливо тому, що їм не подобаються надто довгі імена.
> 
> Ось чому x86-64 має так багато різних назв.
> 
> Проекти з відкритим кодом часто віддають перевагу назві x86-64, яка не містить назв конкретних компаній. У цій книзі постійно використовується назва x86-64.

## Що таке асемблер?

Оскільки машинний код зчитується безпосередньо ЦП, він призначений лише для зручності ЦП, а не для простоти використання людьми. Написання такого типу машинного коду в двійковому редакторі є дуже складним завданням, хоча це й не неможливо. Тому і був винайдений асемблер. Асемблювання — це мова, яка майже однозначно відповідає машинному коду, але її набагато легше читати людям.

Для компіляторів, які виводять власні двійкові файли (на відміну від віртуальної машини чи інтерпретатора), метою зазвичай є виведення асамблеї. Типовий компілятор, який, здається, безпосередньо виводить машинний код, виведе збірку, а потім запустить асемблер у фоновому режимі. Компілятор C, який ми створимо в цій книзі, також виводить збірку.

Перетворення асемблерного коду в машинний код іноді називають «компіляцією», але іноді його також називають «ассемблером», щоб підкреслити, що вхідні дані є асамблеєю.

Можливо, ви вже десь бачили збірку. Якщо ви ще не бачили збірку, зараз саме час подивитися. Давайте скористаємося командою `objdump`, щоб розібрати виконуваний файл і відобразити машинний код, що міститься в ньому, як код складання. Нижче наведено результат розбирання команди `ls`.

```
$ objdump -d -M intel /bin/ls
/bin/ls:     file format elf64-x86-64

Disassembly of section .init:

0000000000003d58 <_init@@Base>:
  3d58:  48 83 ec 08           sub    rsp,0x8
  3d5c:  48 8b 05 7d b9 21 00  mov    rax,QWORD PTR [rip+0x21b97d]
  3d63:  48 85 c0              test   rax,rax
  3d66:  74 02                 je     366a <_init@@Base+0x12>
  3d68:  ff d0                 call   rax
  3d6a:  48 83 c4 08           add    rsp,0x8
  3d6e:  c3                    ret
...
```

У моєму середовищі команда `ls` містить близько 20 000 машинних інструкцій, тому дизассемблований результат також досить довгий, майже 20 000 рядків. Ми включили лише перші кілька сюди.

Код складання зазвичай структурований як один рядок на машинний код. Наприклад, розглянемо такий рядок:

```
  3d58:  48 83 ec 08           sub    rsp,0x8
```

Що означає цей рядок? `3d58` - це адреса пам'яті, яка містить машинний код. Це означає, що під час виконання команди ls інструкції в цьому рядку будуть розміщені в пам’яті за адресою `0x3d58` і виконуватимуться, коли програмний лічильник буде `0x3d58`. Наступні чотири шістнадцяткові числа є фактичним машинним кодом. ЦП зчитує ці дані та виконує їх як інструкції. `sub rsp,0x8` — збірка, яка відповідає цій машинній інструкції. Набір інструкцій центрального процесора буде пояснено в окремій главі, але ця інструкція віднімає 8 з регістру під назвою RSP.

# C та відповідна асемблерна програма

## Простий приклад

Щоб отримати уявлення про те, який саме вивід генерує C-компілятор, порівняймо C-код із відповідним йому асемблерним кодом. Розглянемо найпростіший приклад — наступну програму на C:

```c
int main() {
  return 42;
}
```

Припустимо, що ця програма записана у файл `test1.c`. Її можна скомпілювати таким чином і перевірити, що вона дійсно повертає значення 42:

```shell
$ cc -o test1 test1.c
$ ./test1
$ echo $?
42
```

У C значення, яке повертає функція `main`, стає кодом завершення всієї програми. Цей код завершення не виводиться на екран, але неявно зберігається у змінній оболонки `$?`, тож одразу після завершення команди можна вивести значення цієї змінної командою `echo $?`. Тут ми бачимо, що було повернуто саме `42`.

Асемблерна програма, що відповідає цій C-програмі, виглядає наступним чином:

```asm
.intel_syntax noprefix
.globl main
main:
        mov rax, 42
        ret
```

У цьому асемблері оголошено глобальну мітку `main`, після якої йде код функції. Значення 42 записується в регістр `RAX`, і потім здійснюється повернення з функції. Існує загалом 16 регістрів, які можуть містити цілі числа, включаючи `RAX`. За домовленістю, значення, яке знаходиться в `RAX` після повернення з функції, вважається її результатом. Тому в цьому випадку число 42 записується саме в `RAX`.

Спробуймо скомпілювати й виконати цю асемблерну програму. Файл з асемблерним кодом має розширення `.s`, тож запишіть наведений вище код у файл `test2.s` і виконайте наступні команди:

```shell
$ cc -o test2 test2.s
$ ./test2
$ echo $?
42
```

Як і у випадку з C-програмою, результатом виконання програми став код завершення 42.

Грубо кажучи, C-компілятор — це програма, яка зчитує C-код, такий як у `test1.c`, і генерує асемблерний код на кшталт `test2.s`.

## Приклад із викликом функції

Розглянемо трохи складніший приклад, у якому показано, як код із викликом функції перетворюється на асемблер.

Виклик функції — це не просто **перехід** (*jump*); після завершення викликаної функції програма повинна повернутися до місця, з якого цей виклик був зроблений. Адресу, за якою потрібно відновити виконання, називають **адресою повернення** (*return address*). Якщо виклик функції здійснюється лише один раз, цю адресу можна зберегти в якомусь реєстрі процесора. Але оскільки функції можуть викликатися рекурсивно або вкладено будь-яку кількість разів, адресу повернення потрібно зберігати в пам’яті — конкретно у **стеку**.

Стек можна реалізувати, використовуючи лише одну змінну, яка зберігає адресу його вершини. Ця змінна зберігається у спеціальному регістрі, що називається **стековим вказівником** (*stack pointer*). Архітектура x86-64 підтримує роботу з функціями, маючи спеціальний регістр стекового вказівника та відповідні інструкції. Занесення даних у стек називається **пуш** (*push*), а зняття даних зі стека — **поп** (*pop*).

**Розглянемо приклад на C:**
```c
int plus(int x, int y) {
  return x + y;
}

int main() {
  return plus(3, 4);
}
```
Відповідний асемблерний код виглядає так:

```asm
.intel_syntax noprefix
.globl plus, main

plus:
        add rsi, rdi
        mov rax, rsi
        ret

main:
        mov rdi, 3
        mov rsi, 4
        call plus
        ret
```

1-й рядок вказує на використання Intel-синтаксису. 2-й рядок з `.globl` оголошує функції `plus` і `main` як глобальні, тобто видимі в усій програмі. Це можна тимчасово проігнорувати.

Зосередимось на функції `main`. У C вона викликає `plus` з аргументами. У асемблері є правило: перший аргумент передається через регістр `RDI`, другий — через `RSI`. Тому перші два рядки функції `main` присвоюють значення 3 і 4 цим реєстрам відповідно.

Інструкція `call` викликає функцію. Вона виконує два кроки:

1. Заносить адресу наступної інструкції (`ret`)` у стек — це і є адреса повернення.
2. Переходить до функції, вказаної як аргумент (у цьому випадку — `plus`).

**Функція `plus`**

Функція `plus` складається з трьох інструкцій.

- `add rsi, rdi`: додає значення в `rdi` до `rsi` і зберігає результат у `rsi`. У x86-64 арифметичні інструкції зазвичай працюють із двома операндами, де результат зберігається в першому.
- `mov rax, rsi`: копіює результат із `rsi` у `rax`, оскільки значення, яке повертається з функції, повинно бути в регістрі `RAX`.
- `ret`: ця інструкція:
  1. Знімає зі стека адресу повернення.
  2. Переходить за цією адресою.

Іншими словами, `ret` є зворотною операцією до `call`, і разом вони забезпечують правильну передачу керування між функціями.

Після повернення з `plus`, керування знову опиняється в `main`, а значення в `rax` уже є результатом виклику функції `plus`. Тому інструкція `ret` в `main` повертає це саме значення — як і в оригінальному коді на C.

# Підсумки цього розділу

У цьому розділі ми стисло пояснили, як комп’ютер працює «під капотом» і що саме має робити C‑компілятор. Коли дивишся на асемблер чи машинний код, вони здаються громіздкими й далекими від C, проте, як виявилося, їхня структура доволі прямо відображає ту саму логіку, що й у C‑коді — це, мабуть, помітили багато читачів.

Оскільки в книжці ми ще майже не розглядали конкретні машинні інструкції, значення окремих команд асемблера, показаних через objdump, можуть бути незрозумілими. Та й не потрібно їх одразу знати напам’ять: важливо лише відчути, що кожна інструкція сама по собі робить небагато. На цьому етапі такого інтуїтивного розуміння цілком достатньо.

Нижче наведено ключові моменти розділу у вигляді тез:

- **CPU виконує програму, читаючи й записуючи дані до пам’яті.**
- **І сам виконуваний код, і дані, з якими він працює, зберігаються в оперативній пам’яті;** процесор послідовно зчитує з неї машинні інструкції та виконує їх.
- **У CPU є невеликі комірки пам’яті — реєстри**, і більшість машинних інструкцій описує саме операції між реєстрами.
- **Асемблер — це «читабельна» форма машинного коду**, і типовий C‑компілятор передусім генерує саме асемблерний текст.
- **Функції в C залишаються функціями й в асемблері;** їхні межі та виклики чітко зберігаються.
- **Виклик функцій реалізовано через стек**, де зберігаються адреси повернення та інші дані, потрібні для коректного відновлення виконання.

> **Колонка: Онлайн-компілятор**
> 
> Спостерігати за C‑кодом і результатом його компіляції — чудовий спосіб вивчати асемблерну мову. Але постійно редагувати вихідний код, компілювати його і вручну переглядати асемблерний вивід — це доволі клопіткий процес.
> 
> На щастя, існує дуже зручний вебсайт, який значно спрощує цю задачу — [Compiler Explorer](https://godbolt.org/z/RyNqgE) (відомий також як godbolt). На цьому сайті, якщо ввести C‑код у текстове поле на лівій половині екрана, то в правій половині миттєво з’являється відповідний асемблерний код.
> 
> Коли хочете швидко перевірити, у що саме перетворюється ваш C‑код, цей сервіс стане надзвичайно корисним.

