---
layout: page
title: Вступ у створення компілятора C для тих, хто хоче знати про низькорівневі речі
permalink: /compilers/chibicc
translation_source: https://www.ocf.berkeley.edu/~stefan/fun/chibicc.html
translation_source: https://www.sigbus.info/compilerbook
---

Rui Ueyama <ruiu@cs.stanford.edu>

2020-03-16

- [Вступ](#вступ)
  - [Умовні позначення, використані в цій книзі](#умовні-позначення-використані-в-цій-книзі)
  - [Середовище розробки передбачається в цій книзі](#середовище-розробки-передбачається-в-цій-книзі)
  - [Про автора](#про-автора)
- [Машинна мова та асемблер](#машинна-мова-та-асемблер)
  - [ЦП і пам'ять](#цп-і-память)
  - [Що таке асемблер?](#що-таке-асемблер)
  - [C та відповідна асемблерна програма](#c-та-відповідна-асемблерна-програма)
    - [Простий приклад](#простий-приклад)
    - [Приклад із викликом функції](#приклад-із-викликом-функції)
  - [Підсумки цього розділу](#підсумки-цього-розділу)
- [Створення мови рівня калькулятора](#створення-мови-рівня-калькулятора)
  - [Крок 1: Створення мови, що компілює лише одне ціле число](#крок-1-створення-мови-що-компілює-лише-одне-ціле-число)
  - Step 2: Create a compiler that can add and subtract
  - Step 3: Introduce tokenizer
  - Step 4: Improve error messages
  - Grammar description method and recursive descent parsing
    - Representation of grammatical structure using tree structure
    - Defining grammar using production rules
    - Description of production rules using BNF
    - simple production rules
    - Expressing operator precedence using production rules
    - Productions involving recursion
    - recursive descending parsing
  - stack machine
    - Stack machine concept
    - Compile to stack machine
    - How to create a stack machine on x86-64
  - Step 5: Create a language that can perform four arithmetic operations
  - Step 6: Unary plus and unary minus
  - Step 7: Comparison operators
    - Tokenizer changes
    - new grammar
    - Assembly code generation
- Separate compilation and linking
  - What is separate compilation?
    - Separate compilation and its necessity
    - The necessity of header files and their contents
    - link error
    - Declaration and definition of global variables
  - C standard library and archive files
  - Step 8: File splitting and Makefile changes
    - Split files
    - Makefile changes
- Functions and local variables
  - Step 9: One character local variable
    - Variable area on the stack
    - Tokenizer changes
    - Parser changes
    - lvalue and rvalue
    - How to load a value from any address
    - Code generator changes
    - Main function changes
  - Step 10: Multi-character local variables
  - Step 11: return statement
  - 1973 C compiler
  - Step 12: Add control constructs
  - Step 13: Block
  - Step 14: Respond to function calls
  - Step 15: Address the function definition
  - Binary level interface
- Representation of integers in computers
  - unsigned integer
  - signed integer
  - sign extension
  - Reversal of sign
- Pointers and string literals
  - Step 16: Unary &and Unary*
  - Step 17: Eliminate implicit variable definitions and introduce the int keyword
  - Step 18: Introducing pointer types
    - Define a type that represents a pointer
    - Assign to the value pointed to by the pointer
  - Step 19: Implement pointer addition and subtraction
  - Step 20: sizeof operator
  - Step 21: Implement the array
    - Define an array type
    - Implement implicit type conversion from array to pointer
  - Step 22: Implement array subscripting
  - Step 23: Implement global variables
  - Step 24: Implement the character type
  - Step 25: Implement string literals
  - Step 26: Read input from file
  - Step 27: Line and block comments
  - Step 28: Rewrite the test in C
- Program execution image and initialization formula
  - Executable file structure
  - Data segment contents
  - Initialization expression syntax
  - Global variable initialization expression
  - Local variable initialization expression
- After step 29: [Addition required]
- Static and dynamic links
  - static link
- C type syntax
  - Diagram representing the type
  - Notation for representing types
  - How to read C types
    - How to read non-nested types
    - How to read nested types
  - Exercises
- in conclusion
- Appendix 1: x86-64 Instruction Set Cheat Sheet
  - List of integer registers
  - memory access
  - function call
  - conditional branch
  - conditional assignment
  - Integer/logical operations
- Appendix 2: Version control with Git
  - Workflow using Git
  - Points to note when committing
  - Internal structure of Git
- Appendix 3: Creating a development environment using Docker
  - Setup steps
  - Build using containers
  - Add new application to container
- Reference materials
- index

# Вступ

Ця онлайн-книга зараз пишеться. Це не остаточна версія. [форма зворотного зв'язку](https://goo.gl/forms/DWmgm5fChpJ6IEFI3)

Ця книга наповнена вмістом, який занадто багато, щоб включити в одну книгу. У цій книзі ми створимо програму, яка перетворює вихідний код, написаний мовою Сі, на мову асемблера, тобто компілятор Сі. Сам компілятор також розроблено з використанням C. Найближчою метою є можливість самостійного розміщення, тобто компіляції власного вихідного коду за допомогою домашнього компілятора.

У цій книзі я вирішив пояснити різні теми в прогресивній манері, щоб не ускладнювати пояснення компіляторів. Ось чому:

Концептуально компілятори можна розділити на кілька етапів: аналіз, проміжні проходи та генерація коду. Загальний підхід у підручниках полягає в тому, щоб пояснювати кожну тему розділами, але книги з таким підходом, як правило, стають занадто вузькими та глибокими посередині, що ускладнює для читачів слідування.

Крім того, за допомогою методу розробки для створення кожного етапу неможливо запустити компілятор, доки не будуть завершені всі етапи, тому важко помітити, чи є певна помилка у вашому розумінні чи коді, доки весь етап не почне працювати. Недоліком є ​​те, що ви не можете. По-перше, ви насправді не знаєте, якими будуть вхідні дані наступного етапу, доки ви не створите його самі, тому ви насправді не знаєте, що виводити на попередньому етапі. Інша проблема полягає в тому, що важко залишатися мотивованим, оскільки ви не можете скомпілювати жодного коду, поки він не буде завершений.

У цій книзі я вирішив застосувати інший підхід, щоб уникнути цієї пастки. На початку книги ви реалізуєте ``власну мову'' з дуже простою специфікацією мови. Мова настільки проста, що вам не потрібно багато знати про те, як написати компілятор для її реалізації. Після цього читач продовжуватиме додавати функції до «власної мови» за допомогою цієї книги, і зрештою розвине її до чогось, що сумісно з C.

У такому методі інкрементальної розробки ви створюєте компілятор крок за кроком, роблячи невеликі коміти. За допомогою цього методу розробки компілятор завжди в якомусь сенсі «завершений» при кожному коміті. На одному етапі це може бути лише рівень калькулятора, на іншому це може бути дуже обмежена підмножина C, а на іншому це може бути мова, яку майже можна назвати C. Справа в тому, що на кожному етапі ми прагнемо до мови з прийнятними специфікаціями, які відповідають рівню завершеності на цьому етапі. Під час розробки ми не наголошуємо лише на деяких функціях, щоб це виглядало як мова C.

Ми також пояснимо структури даних, алгоритми та знання з інформатики поетапно відповідно до стадії розробки.

Поступовий розвиток досягає мети, щоб у будь-який момент часу під час читання цієї книги читач мав повне знання про те, як створити розумну мову на цьому рівні. Це набагато краще, ніж стан, коли лише деякі теми створення компілятора надзвичайно детальні. До того часу, коли ви закінчите читати цю книгу, ви будете добре обізнані з усіма темами.

Ця книга також пояснює, як писати великі програми з нуля. Уміння створювати великі програми — унікальне вміння, яке відрізняється від вивчення структур даних і алгоритмів, але я не думаю, що існує багато книг, які пояснюють такі речі. Крім того, навіть якщо хтось пояснить вам це, ви не знатимете, чи є метод розробки хорошим чи поганим, якщо ви не випробували його насправді. Ця книга розроблена таким чином, що процес розробки вашої власної мови на мову C дасть вам практичний досвід хорошого методу розробки.

Якщо план автора вдасться, прочитавши цю книгу, читачі не тільки дізнаються про техніку створення компіляторів і набору інструкцій центрального процесора, а й дізнаються, як розбивати великі програми на маленькі кроки і створювати їх потроху. Ви дізнаєтесь про методи тестування, методи контролю версій і навіть про те, як підготуватися до такого амбітного проекту, як написання компілятора.

Цільова аудиторія цієї книги — звичайні програмісти на C. Вам не потрібно бути суперпрограмістом на C, який добре знає специфікацію мови C. Достатньо, щоб ви розбиралися в покажчиках і масивах і могли принаймні приділити трохи часу читанню невеликих програм C, написаних іншими.

Під час написання цієї книги я намагався не лише пояснити специфікації мови та специфікації процесора, але й якомога докладніше пояснити, чому було обрано саме такий дизайн. Ми також включили колонки про компілятори, центральні процесори, комп’ютерну індустрію та її історію, які зацікавлять читачів і зроблять її читанням приємним.

Створення компілятора - це дуже весело. На початку моя саморобна мова могла робити лише неймовірно прості речі, але, продовжуючи її розвивати, вона швидко стала нагадувати мову C настільки, що навіть я був здивований, і вона почала працювати, наче за помахом чарівної палички. стати. Під час фактичної розробки я часто дивуюся тому, що великий тестовий код, який, на мою думку, не буде добре скомпільований у той час, компілюється без помилок і працює ідеально правильно. Такий код нелегко зрозуміти самому, навіть дивлячись на скомпільовану збірку. Іноді я навіть відчуваю, що мій компілятор має більше розуму, ніж я, автор. Компілятор — це програма, яка, навіть якщо ви знаєте, як вона працює, все одно дивуєтеся, чому вона працює так добре. Я впевнений, що ви теж закохаєтесь у його чарівність.

Отже, без зайвих слів, давайте разом з автором стрибнемо у світ розробки компілятора!

> **Стаття: Чому мова C?**
> 
> Чому серед багатьох доступних мов програмування ви вибрали C для цієї книги? Або чому б не рідна мова? Стосовно цього моменту немає жодних причин, чому це обов’язково має бути C, але якщо вам потрібно вибрати мову, щоб навчитися створювати компілятор, який виводить рідний код, C є розумним вибором, який не дуже поширений. Я думаю, що це один із них.
> 
> Інтерпретовані мови не дозволяють дізнатися багато про нижчі рівні. З іншого боку, C зазвичай компілюється в асемблер, тому, створивши компілятор, ви можете дізнатися про набір інструкцій процесора та роботу програм, а також про сам C.
> 
> C широко використовується, тому, коли у вас є робочий компілятор, ви можете пограти з компіляцією стороннього вихідного коду, який ви завантажуєте з Інтернету. Наприклад, ви можете зібрати та грати в mini Unix xv6. Якщо компілятор достатньо зрілий, можна буде скомпілювати навіть ядро ​​Linux. Така насолода неможлива з другорядними або доморощеними мовами.
> 
> C++ — це статично типізована мова, яка компілюється до рідної машинної мови, як-от C, і використовується принаймні так само широко, як і C. Однак специфікації мови для C++ настільки великі, що неможливо легко створити власний компілятор, тому це нереалістичний варіант.
> 
> Розробка та реалізація оригінальної мови — це добре з точки зору вдосконалення відчуття мовного дизайну, але є й підводні камені. Речі, які важко реалізувати, можна уникнути, уникаючи їх у специфікації мови. Це не стосується таких мов, як C, де специфікація мови дається як стандарт. Я вважаю, що це обмеження досить добре з точки зору навчання.

## Умовні позначення, використані в цій книзі

Функції, вирази, команди тощо відображаються в тексті моноширинним шрифтом, наприклад, `main`, `foo=3`, `make`.

Код, який охоплює кілька рядків, відображається у рамці за допомогою моноширинного шрифту, як показано нижче.

```c
int main() {
  printf("Hello world!\n");
  return 0;
}
```

Якщо рамковий код є командою оболонки, яку користувач має дослівно ввести, рядок $, що починається з, представляє підказку. $Введіть решту цього рядка ($але не решту) в оболонку. $Інші рядки представляють результат введеної вами команди. Наприклад, блок нижче make є прикладом того, що відбувається, коли користувач вводить рядок `make` і натискає Enter. Результатом команди є `make: Nothing to be done for 'all'`:

## Середовище розробки передбачається в цій книзі

У цій книзі передбачається, що 64-розрядне середовище Linux працює на так званому звичайному ПК, такому як Intel або AMD. Будь ласка, інсталюйте інструменти розробки, такі як gcc, і створіть заздалегідь відповідно до дистрибутива, який ви використовуєте. Якщо ви користуєтеся Ubuntu, ви можете встановити команди, які використовуються в цій книзі, виконавши таку команду.

```shell
$ sudo apt update
$ sudo apt install -y gcc make git binutils libc6-dev
```

Хоча macOS досить сумісна з Linux на рівні джерела збірки, вона не є повністю сумісною (зокрема, функція під назвою «статичне зв’язування» не підтримується). Хоча можна створити компілятор C для macOS, використовуючи інформацію з цієї книги, якщо ви спробуєте це, ви, ймовірно, зіткнетеся з низкою незначних несумісностей. Не рекомендується одночасно вивчати прийоми створення компілятора C і відмінності між macOS і Linux. Коли щось не працює, важко зрозуміти, яке розуміння неправильне.

Тому ця книга не стосується macOS. У macOS використовуйте якесь віртуальне середовище, щоб підготувати середовище Linux. Якщо ви вперше готуєте віртуальне середовище Linux, зверніться до [Додатку 3](#), у якому підсумовано, як створити середовище розробки за допомогою Docker.

Windows не сумісна з Linux на рівні джерела складання. Однак у Windows 10 можна запускати Linux у Windows як одну програму, і, використовуючи це, ви можете продовжувати розробку у Windows. Програма під назвою Windows Subsystem for Linux (WSL) є таким Linux-сумісним середовищем. Впроваджуючи вміст цієї книги в Windows, інсталюйте WSL і продовжуйте розробку в ньому.

> **Стаття: крос-компілятор**
> 
> Машина, на якій працює компілятор, називається «хостом», а машина, на якій виконується код, виведений компілятором, називається «цільовою». Хоча в цій книзі обидва є 64-розрядними середовищами Linux, хост і ціль не обов’язково повинні бути однаковими.
> 
> Компілятор, хост і ціль якого відрізняються, називається крос-компілятором. Наприклад, компілятор, який працює в Windows і створює виконуваний файл для Raspberry Pi, є крос-компілятором. Крос-компілятори часто використовуються, коли цільова машина занадто слабка або спеціалізована для запуску компілятора.

## Про автора

Руї Уеяма ( [@rui314](https://twitter.com/rui314) ). Він є оригінальним автором і поточним супроводжувачем високошвидкісного компонувальника lld, який використовується як стандартний компонувальник для створення виконуваних файлів у багатьох ОС і проектах, включаючи Android (версія Q або новіша), FreeBSD (12 або новіша), Nintendo Switch, Chrome і Firefox. (Отже, існує висока ймовірність того, що двійковий файл, створений інструментом, який я написав, уже є на вашому комп’ютері.) Він також є автором компактного компілятора C [8cc](https://github.com/rui314/8cc). В основному я пишу есе про програмне забезпечення в [нотатках](https://note.mu/ruiu).

> **Стаття: компілятор, який компілює компілятор**
> 
> Ситуації з самопосиланням, такі як компілятор C, написаний мовою C, не є рідкістю. Багато реалізацій мови, крім C, написані з використанням самої мови.
> 
> Якщо вже існує реалізація мови X, немає ніяких логічних протиріч у створенні нового компілятора X за допомогою самої мови. Якщо ви вирішите самостійно розміщувати компілятор, ви можете просто розробляти його за допомогою існуючого компілятора, а коли закінчите, переключитися на свій власний. Саме це ми намагаємося зробити в цій книзі.
> 
> Але що, якщо у вас немає наявного компілятора? У такому випадку у вас немає іншого вибору, як писати іншою мовою. Під час написання вашого першого компілятора для мови X з наміром самостійного розміщення вам потрібно буде написати його за допомогою існуючої мови Y, яка відрізняється від X, і коли компілятор буде завершено, вам потрібно буде переписати сам компілятор з мови Y на мову X.
> 
> Компілятори для сучасних складних мов програмування також є іншими компіляторами, які використовувалися для компіляції реалізацій цієї мови, і так далі, поки на початку комп’ютерів хтось не зміг безпосередньо написати машинний код. Ви повинні отримати простий асемблер, який ви написали. Ми не знаємо, чи існував один або кілька асемблерів, які в певному сенсі є основними предками всіх існуючих реалізацій мови, але немає сумніву, що сучасні компілятори починалися з дуже невеликої кількості предків. Шо. Виконувані файли, крім компіляторів, також зазвичай генеруються компіляторами, тому майже всі існуючі виконувані файли є непрямими нащадками вихідного асемблера. Це цікава історія, схожа на походження життя.

---

# Машинна мова та асемблер

Мета цього розділу — дати вам приблизне уявлення про компоненти, з яких складається комп’ютер, і про те, який код ми повинні виводити з компілятора C, який ми створюємо. Ми поки не будемо вдаватися в особливості інструкцій ЦП. По-перше, важливо зрозуміти концепцію.

## ЦП і пам'ять

Компоненти, з яких складається комп’ютер, можна умовно розділити на центральний процесор і пам’ять. Пам'ять - це пристрій, який може зберігати дані, а центральний процесор - це пристрій, який читає та записує цю пам'ять для виконання певної обробки.

Концептуально, пам'ять виглядає для центрального процесора як великий масив байтів, до якого можна отримати довільний доступ. Коли центральний процесор звертається до пам’яті, він визначає, до якого байту пам’яті він хоче отримати доступ, вказуючи число, і це число називається «адресою». Наприклад, «прочитати 8 байт даних з адреси 16» означає зчитування 8 байт даних, починаючи з 16-го байта пам’яті, який виглядає як масив байтів. Те саме можна сказати як «прочитати 8 байт даних з адреси 16».

У пам’яті зберігаються як програми, які виконує ЦП, так і дані, які ці програми читають і записують. Центральний процесор зберігає адресу інструкції, що виконується в даний момент, зчитує інструкцію з цієї адреси, виконує те, що там записано, а потім читає та виконує наступну інструкцію. Адреса інструкції, що виконується в даний момент, називається «Лічильником програми» (PC) або «Покажчиком інструкції» (IP). Фактичний формат програми, яку виконує центральний процесор, називається «машинним кодом».

Лічильник програм не обов'язково лінійно переходить до наступної інструкції. Тип інструкції центрального процесора, який називається «інструкція розгалуження», дозволяє встановити лічильник програм на будь-яку адресу, окрім наступної інструкції. Ця функція дозволяє реалізувати оператори if, цикли тощо. Встановлення лічильника програм у місце, відмінне від наступної інструкції, називається «стрибком» або «розгалуженням».

Крім лічильника програм, центральний процесор також має невелику кількість областей зберігання даних. Наприклад, процесори Intel і AMD мають 16 розташувань, які можуть зберігати 64-розрядні цілі числа. Ця область називається «реєстр». Пам'ять є зовнішнім пристроєм центрального процесора, і для читання та запису в неї потрібен деякий час, але регістри знаходяться всередині центрального процесора, і до них можна отримати доступ без затримки.

Більшість машинних кодів відформатовано таким чином, що деякі операції виконуються з використанням значень двох регістрів, а результат записується назад у регістр. Таким чином, виконання програми передбачає зчитування ЦП даних із пам’яті в регістр, виконання якогось обчислення між регістрами та запис результату назад у пам’ять.

Конкретна інструкція машинної мови разом називається «архітектурою набору інструкцій» (ISA) або «набором інструкцій». Існує не лише один тип набору інструкцій; кожен ЦП може створювати його як завгодно. Однак, оскільки ту саму програму неможливо запустити без сумісності на рівні машинного коду, існує не так багато варіацій у наборах інструкцій. Комп’ютери використовують набір інструкцій під назвою x86-64, розроблений компанією Intel та її виробником сумісних мікросхем AMD. Хоча x86-64 є одним із основних наборів інструкцій, він не домінує на ринку. Наприклад, iPhone і Android використовують набір інструкцій під назвою ARM.

> Стаття: імена набору інструкцій x86-64
> 
> x86-64 також іноді називають AMD64, Intel 64, x64 тощо. Існує історична причина, чому той самий набір інструкцій має кілька таких назв.
> 
> Набір інструкцій x86 був створений Intel у 1978 році, але AMD розширила його до 64-розрядного. Приблизно в 2000 році, коли виникла потреба в 64-розрядних процесорах, Intel була прихильна до абсолютно нового набору інструкцій під назвою Itanium і не потрудилася вирішувати конкуруючу 64-розрядну версію x86. Скориставшись цією можливістю, AMD сформулювала та випустила специфікацію 64-bit x86. Це x86-64. Пізніше AMD перейменувала x86-64 на AMD64, можливо, як стратегію брендингу.
> 
> Після цього провал Itanium став очевидним, і Intel не мала іншого вибору, окрім як створити 64-розрядну версію x86. Однак на той час було випущено досить багато чіпів AMD64, тому було важко розробити розширений набір інструкцій, який був би схожим, але не ідентичним, і Intel вирішила прийняти набір інструкцій, сумісний з AMD. Кажуть, що Microsoft також чинила тиск з метою підтримки сумісності. У той час Intel прийняла набір інструкцій, який був майже ідентичний AMD64, і назвала його IA-32e. Той факт, що його назвали IA-32e (розширення Intel Architecture 32) замість 64, здається, показує тривалу прихильність до невдалого набору інструкцій, оскільки Itanium все ще є основою 64-розрядних процесорів. Тоді Intel вирішила повністю відмовитися від Itanium, і IA-32e було перейменовано на більш традиційну Intel 64. Microsoft називає x86-64 x64, можливо тому, що їм не подобаються надто довгі імена.
> 
> Ось чому x86-64 має так багато різних назв.
> 
> Проекти з відкритим кодом часто віддають перевагу назві x86-64, яка не містить назв конкретних компаній. У цій книзі постійно використовується назва x86-64.

## Що таке асемблер?

Оскільки машинний код зчитується безпосередньо ЦП, він призначений лише для зручності ЦП, а не для простоти використання людьми. Написання такого типу машинного коду в двійковому редакторі є дуже складним завданням, хоча це й не неможливо. Тому і був винайдений асемблер. Асемблювання — це мова, яка майже однозначно відповідає машинному коду, але її набагато легше читати людям.

Для компіляторів, які виводять власні двійкові файли (на відміну від віртуальної машини чи інтерпретатора), метою зазвичай є виведення асамблеї. Типовий компілятор, який, здається, безпосередньо виводить машинний код, виведе збірку, а потім запустить асемблер у фоновому режимі. Компілятор C, який ми створимо в цій книзі, також виводить збірку.

Перетворення асемблерного коду в машинний код іноді називають «компіляцією», але іноді його також називають «ассемблером», щоб підкреслити, що вхідні дані є асамблеєю.

Можливо, ви вже десь бачили збірку. Якщо ви ще не бачили збірку, зараз саме час подивитися. Давайте скористаємося командою `objdump`, щоб розібрати виконуваний файл і відобразити машинний код, що міститься в ньому, як код складання. Нижче наведено результат розбирання команди `ls`.

```
$ objdump -d -M intel /bin/ls
/bin/ls:     file format elf64-x86-64

Disassembly of section .init:

0000000000003d58 <_init@@Base>:
  3d58:  48 83 ec 08           sub    rsp,0x8
  3d5c:  48 8b 05 7d b9 21 00  mov    rax,QWORD PTR [rip+0x21b97d]
  3d63:  48 85 c0              test   rax,rax
  3d66:  74 02                 je     366a <_init@@Base+0x12>
  3d68:  ff d0                 call   rax
  3d6a:  48 83 c4 08           add    rsp,0x8
  3d6e:  c3                    ret
...
```

У моєму середовищі команда `ls` містить близько 20 000 машинних інструкцій, тому дизассемблований результат також досить довгий, майже 20 000 рядків. Ми включили лише перші кілька сюди.

Код складання зазвичай структурований як один рядок на машинний код. Наприклад, розглянемо такий рядок:

```
  3d58:  48 83 ec 08           sub    rsp,0x8
```

Що означає цей рядок? `3d58` - це адреса пам'яті, яка містить машинний код. Це означає, що під час виконання команди ls інструкції в цьому рядку будуть розміщені в пам’яті за адресою `0x3d58` і виконуватимуться, коли програмний лічильник буде `0x3d58`. Наступні чотири шістнадцяткові числа є фактичним машинним кодом. ЦП зчитує ці дані та виконує їх як інструкції. `sub rsp,0x8` — збірка, яка відповідає цій машинній інструкції. Набір інструкцій центрального процесора буде пояснено в окремій главі, але ця інструкція віднімає 8 з регістру під назвою RSP.

# C та відповідна асемблерна програма

## Простий приклад

Щоб отримати уявлення про те, який саме вивід генерує C-компілятор, порівняймо C-код із відповідним йому асемблерним кодом. Розглянемо найпростіший приклад — наступну програму на C:

```c
int main() {
  return 42;
}
```

Припустимо, що ця програма записана у файл `test1.c`. Її можна скомпілювати таким чином і перевірити, що вона дійсно повертає значення 42:

```shell
$ cc -o test1 test1.c
$ ./test1
$ echo $?
42
```

У C значення, яке повертає функція `main`, стає кодом завершення всієї програми. Цей код завершення не виводиться на екран, але неявно зберігається у змінній оболонки `$?`, тож одразу після завершення команди можна вивести значення цієї змінної командою `echo $?`. Тут ми бачимо, що було повернуто саме `42`.

Асемблерна програма, що відповідає цій C-програмі, виглядає наступним чином:

```asm
.intel_syntax noprefix
.globl main
main:
        mov rax, 42
        ret
```

У цьому асемблері оголошено глобальну мітку `main`, після якої йде код функції. Значення 42 записується в регістр `RAX`, і потім здійснюється повернення з функції. Існує загалом 16 регістрів, які можуть містити цілі числа, включаючи `RAX`. За домовленістю, значення, яке знаходиться в `RAX` після повернення з функції, вважається її результатом. Тому в цьому випадку число 42 записується саме в `RAX`.

Спробуймо скомпілювати й виконати цю асемблерну програму. Файл з асемблерним кодом має розширення `.s`, тож запишіть наведений вище код у файл `test2.s` і виконайте наступні команди:

```shell
$ cc -o test2 test2.s
$ ./test2
$ echo $?
42
```

Як і у випадку з C-програмою, результатом виконання програми став код завершення 42.

Грубо кажучи, C-компілятор — це програма, яка зчитує C-код, такий як у `test1.c`, і генерує асемблерний код на кшталт `test2.s`.

## Приклад із викликом функції

Розглянемо трохи складніший приклад, у якому показано, як код із викликом функції перетворюється на асемблер.

Виклик функції — це не просто **перехід** (*jump*); після завершення викликаної функції програма повинна повернутися до місця, з якого цей виклик був зроблений. Адресу, за якою потрібно відновити виконання, називають **адресою повернення** (*return address*). Якщо виклик функції здійснюється лише один раз, цю адресу можна зберегти в якомусь реєстрі процесора. Але оскільки функції можуть викликатися рекурсивно або вкладено будь-яку кількість разів, адресу повернення потрібно зберігати в пам’яті — конкретно у **стеку**.

Стек можна реалізувати, використовуючи лише одну змінну, яка зберігає адресу його вершини. Ця змінна зберігається у спеціальному регістрі, що називається **стековим вказівником** (*stack pointer*). Архітектура x86-64 підтримує роботу з функціями, маючи спеціальний регістр стекового вказівника та відповідні інструкції. Занесення даних у стек називається **пуш** (*push*), а зняття даних зі стека — **поп** (*pop*).

**Розглянемо приклад на C:**
```c
int plus(int x, int y) {
  return x + y;
}

int main() {
  return plus(3, 4);
}
```
Відповідний асемблерний код виглядає так:

```asm
.intel_syntax noprefix
.globl plus, main

plus:
        add rsi, rdi
        mov rax, rsi
        ret

main:
        mov rdi, 3
        mov rsi, 4
        call plus
        ret
```

1-й рядок вказує на використання Intel-синтаксису. 2-й рядок з `.globl` оголошує функції `plus` і `main` як глобальні, тобто видимі в усій програмі. Це можна тимчасово проігнорувати.

Зосередимось на функції `main`. У C вона викликає `plus` з аргументами. У асемблері є правило: перший аргумент передається через регістр `RDI`, другий — через `RSI`. Тому перші два рядки функції `main` присвоюють значення 3 і 4 цим реєстрам відповідно.

Інструкція `call` викликає функцію. Вона виконує два кроки:

1. Заносить адресу наступної інструкції (`ret`)` у стек — це і є адреса повернення.
2. Переходить до функції, вказаної як аргумент (у цьому випадку — `plus`).

**Функція `plus`**

Функція `plus` складається з трьох інструкцій.

- `add rsi, rdi`: додає значення в `rdi` до `rsi` і зберігає результат у `rsi`. У x86-64 арифметичні інструкції зазвичай працюють із двома операндами, де результат зберігається в першому.
- `mov rax, rsi`: копіює результат із `rsi` у `rax`, оскільки значення, яке повертається з функції, повинно бути в регістрі `RAX`.
- `ret`: ця інструкція:
  1. Знімає зі стека адресу повернення.
  2. Переходить за цією адресою.

Іншими словами, `ret` є зворотною операцією до `call`, і разом вони забезпечують правильну передачу керування між функціями.

Після повернення з `plus`, керування знову опиняється в `main`, а значення в `rax` уже є результатом виклику функції `plus`. Тому інструкція `ret` в `main` повертає це саме значення — як і в оригінальному коді на C.

# Підсумки цього розділу

У цьому розділі ми стисло пояснили, як комп’ютер працює «під капотом» і що саме має робити C‑компілятор. Коли дивишся на асемблер чи машинний код, вони здаються громіздкими й далекими від C, проте, як виявилося, їхня структура доволі прямо відображає ту саму логіку, що й у C‑коді — це, мабуть, помітили багато читачів.

Оскільки в книжці ми ще майже не розглядали конкретні машинні інструкції, значення окремих команд асемблера, показаних через objdump, можуть бути незрозумілими. Та й не потрібно їх одразу знати напам’ять: важливо лише відчути, що кожна інструкція сама по собі робить небагато. На цьому етапі такого інтуїтивного розуміння цілком достатньо.

Нижче наведено ключові моменти розділу у вигляді тез:

- **CPU виконує програму, читаючи й записуючи дані до пам’яті.**
- **І сам виконуваний код, і дані, з якими він працює, зберігаються в оперативній пам’яті;** процесор послідовно зчитує з неї машинні інструкції та виконує їх.
- **У CPU є невеликі комірки пам’яті — реєстри**, і більшість машинних інструкцій описує саме операції між реєстрами.
- **Асемблер — це «читабельна» форма машинного коду**, і типовий C‑компілятор передусім генерує саме асемблерний текст.
- **Функції в C залишаються функціями й в асемблері;** їхні межі та виклики чітко зберігаються.
- **Виклик функцій реалізовано через стек**, де зберігаються адреси повернення та інші дані, потрібні для коректного відновлення виконання.

> **Колонка: Онлайн-компілятор**
> 
> Спостерігати за C‑кодом і результатом його компіляції — чудовий спосіб вивчати асемблерну мову. Але постійно редагувати вихідний код, компілювати його і вручну переглядати асемблерний вивід — це доволі клопіткий процес.
> 
> На щастя, існує дуже зручний вебсайт, який значно спрощує цю задачу — [Compiler Explorer](https://godbolt.org/z/RyNqgE) (відомий також як godbolt). На цьому сайті, якщо ввести C‑код у текстове поле на лівій половині екрана, то в правій половині миттєво з’являється відповідний асемблерний код.
> 
> Коли хочете швидко перевірити, у що саме перетворюється ваш C‑код, цей сервіс стане надзвичайно корисним.

# Створення мови рівня калькулятора

У цьому розділі, як перший крок до створення компілятора C, ми реалізуємо підтримку чотирьох основних арифметичних операцій та інших арифметичних операторів, щоб мати змогу компілювати вирази на кшталт:

```
30 + (4 - 2) * -5
```

На перший погляд, це може здаватися простим завданням, але насправді воно досить складне. У математичних виразах існує структура: наприклад, вирази в дужках мають вищий пріоритет, множення має вищий пріоритет за додавання тощо. Якщо не зрозуміти цю структуру належним чином, обчислення буде неправильним. Проте вхідний вираз — це всього лише плоска послідовність символів, а не структуровані дані. Щоб правильно оцінити вираз, потрібно проаналізувати послідовність символів і вивести приховану в ній структуру.

Такі задачі синтаксичного аналізу дуже складно розв’язати без попередніх знань. У минулому, особливо в період з 1950-х по 1970-ті роки, ці задачі вважалися складними, і над ними активно працювали, розробляючи різноманітні алгоритми. Завдяки тим зусиллям сьогодні синтаксичний аналіз уже не є настільки складною задачею, якщо знати, як до неї підходити.

У цьому розділі ми пояснимо один з найпоширеніших алгоритмів синтаксичного аналізу — парсер рекурсивного спуску  (recursive descent parsing). Цей метод використовують компілятори C/C++, якими ви, ймовірно, користуєтеся щодня, такі як GCC і Clang.

Потреба аналізувати текст із певною структурою виникає не лише при створенні компіляторів, а й у багатьох інших ситуаціях програмування. Техніки, які ви вивчите в цьому розділі, можна застосовувати і до таких задач. Без перебільшення можна сказати, що методи синтаксичного аналізу, які ми розглянемо, — це інструменти на все життя. Прочитайте цей розділ, зрозумійте алгоритм і додайте техніку синтаксичного аналізу до вашої програмістської скарбнички навичок.

## Крок 1: Створення мови, що компілює лише одне ціле число

Розгляньмо найпростіший можливий підмножину мови C. Якою мовою ви її уявляєте? Мовою, що містить лише функцію main? Або мовою, яка складається лише з одного виразу? Якщо звести все до абсолютного мінімуму, можна сказати, що мова, яка складається лише з одного цілого числа, є найпростішим можливим підмножиною.

У цьому кроці ми реалізуємо саме таку — найпростішу — мову.

Програма, яку ми створимо на цьому етапі, буде компілятором, що зчитує одне число з вхідних даних і генерує асемблерний код, який завершує виконання програми з цим числом як кодом завершення. Іншими словами, якщо вхідні дані — це просто рядок, наприклад 42, то компілятор має вивести такий асемблерний код:

```asm
.intel_syntax noprefix
.globl main

main:
        mov rax, 42
        ret
```

Рядок `.intel_syntax noprefix` — це директива асемблера, яка вказує, що ми використовуємо стиль Intel для запису асемблерного коду (існує кілька стилів, і цей — той, який використовується в цій книзі). У компіляторі, який ви створюєте, завжди додавайте цей рядок на початку як стандартну частину виводу. Інші рядки — ті самі, що ми вже пояснювали в попередньому розділі.

Можливо, дехто з читачів подумає: "Такий простий програмний код — хіба це компілятор?" Чесно кажучи, автор теж так думає. Але з технічної точки зору, ця програма приймає на вхід мову, що складається з одного цілого числа, і генерує відповідний машинний код — отже, за визначенням, це цілком справжній компілятор. І навіть така проста програма стане основою, яку ми зможемо поступово ускладнювати, тож почати з неї — слушне рішення.

Насправді, якщо дивитися на загальну структуру процесу розробки, цей крок є дуже важливим. Саме цей базовий компілятор ми будемо використовувати як скелет для подальшого розвитку. На цьому етапі ми не лише створимо ядро компілятора, а й налаштуємо файл збірки (Makefile), автоматичне тестування і репозиторій Git. Давайте розглянемо кожен із цих процесів по черзі.

До речі, компілятор, який ми створюємо в цій книзі, має назву 9cc. cc — це загальноприйнята абревіатура для "C compiler". Число 9 особливого значення не має — попередня версія компілятора, створена автором, мала назву 8cc, тож 9cc — це наступна ітерація. Звісно, ви можете вибрати будь-яку назву для власного компілятора. Головне — не витрачайте надто багато часу на вибір назви і не відкладайте через це саму розробку. Назву, включно з назвою репозиторію на GitHub, завжди можна змінити пізніше, тому почніть із чогось простого.

> **Колонка: Нотація Intel та AT&T**
> 
> Окрім Intel-нотації, яка використовується в цій книзі, існує також AT&T-нотація, що широко застосовується в Unix-системах. Наприклад, gcc та objdump за замовчуванням виводять асемблерний код саме в AT&T-нотації.
> 
> В AT&T-нотації результат записується як другий аргумент інструкції. Це означає, що в командах з двома аргументами порядок аргументів буде обернений порівняно з Intel-нотацією. Крім того:
> 
> Імена регістрів починаються з префікса `%`, наприклад `%rax`.
> 
> Числові значення мають префікс `$`, наприклад `$42`.
> 
> Для доступу до пам’яті замість квадратних дужок `[]` використовуються круглі `()`, і синтаксис має свій особливий вигляд.
> 
> Нижче наведено кілька прикладів для порівняння:

```asm
mov rbp, rsp            // Intel
mov %rsp, %rbp          // AT&T

mov rax, 8              // Intel
mov $8, %rax            // AT&T

mov [rbp + rcx * 4 - 8], rax     // Intel
mov %rax, -8(rbp, rcx, 4)        // AT&T
```
> 
> У цьому компіляторі ми обрали Intel-нотацію, оскільки вона є читабельнішою, особливо для новачків. Крім того, офіційна документація Intel щодо інструкцій також використовує саме цей стиль, що дозволяє легко переносити приклади з мануалів без перетворення.
> 
> Щодо виразності обох нотацій — вона абсолютно однакова. Яку б нотацію ви не використали, згенерований машинний код буде ідентичним.

### Створення ядра компілятора

Зазвичай компілятор отримує вхідні дані у вигляді файлу, але на цьому етапі, щоб не ускладнювати задачу відкриттям і зчитуванням файлів, ми передаватимемо код безпосередньо як перший аргумент командного рядка.

C-програму, яка зчитує це значення як число, і вбудовує його в стандартну структуру асемблерного коду, можна написати дуже просто. Вона буде виглядати приблизно так:

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv) {
  if (argc != 2) {
    fprintf(stderr, "Неправильна кількість аргументів.\n");
    return 1;
  }

  printf(".intel_syntax noprefix\n");
  printf(".globl main\n");
  printf("main:\n");
  printf("  mov rax, %d\n", atoi(argv[1]));
  printf("  ret\n");
  return 0;
}
```

Створіть порожній каталог із назвою `9cc`, і в ньому створіть файл `9cc.c`, який міститиме програму, описану вище. Після цього спробуйте виконати `9cc` з командного рядка, як показано нижче, щоб перевірити, чи програма працює належним чином.

```shell
$ cc -o 9cc 9cc.c
$ ./9cc 123 > tmp.s
```

У першому рядку ми компілюємо файл `9cc.c` і створюємо виконуваний файл з назвою `9cc`. У другому рядку ми передаємо число `123` як вхідний аргумент програмі `9cc`, яка генерує асемблерний код і записує його у файл `tmp.s`.

Давайте перевіримо вміст файлу `tmp.s`, щоб переконатися, що все працює правильно.

```shell
$ cat tmp.s
.intel_syntax noprefix
.globl main
main:
  mov rax, 123
  ret
```

Як бачите, асемблерний код було успішно згенеровано. Тепер ми можемо передати цей асемблерний файл асемблеру, щоб створити виконуваний файл.

У системах Unix команда `cc` (або `gcc`) слугує не лише компілятором C чи C++, а й універсальним інтерфейсом (фронтендом) до багатьох мов. Вона визначає мову за розширенням вхідного файлу і автоматично викликає відповідний компілятор або асемблер. Тому, як і у випадку компіляції `9cc.c`, якщо ми передамо асемблерний файл з розширенням `.s` до `cc`, він його засемблює.

Нижче наведено приклад, як виконується асемблювання, запуск програми та перевірка коду завершення:

```shell
$ cc -o tmp tmp.s
$ ./tmp
$ echo $?
123
```

У Unix оболонках (наприклад, bash) змінна `$?` містить код завершення попередньої команди. У прикладі вище виводиться число `123` — саме те, яке ми передали компілятору 9cc як аргумент. Це означає, що програма працює правильно.

Спробуйте передати інші числа в межах `0–255` (оскільки у Unix коди завершення процесів обмежені цим діапазоном) і переконайтесь, що `9cc` працює як слід у кожному випадку.

### Створення автоматичних тестів

Багато хто з читачів, особливо якщо програмує для себе як хобі, можливо, ніколи не писав тести. Але в цій книзі ми писатимемо тест-код щоразу, коли будемо розширювати компілятор. Спочатку це може здаватися зайвим або нудним, але дуже швидко ви зрозумієте, наскільки це зручно й корисно.

Якщо не писати тести, вам доведеться вручну запускати одні й ті самі перевірки знову й знову після кожної зміни — і це, повірте, набагато виснажливіше та менш надійно.

Багато хто вважає написання тестів нудним саме через ускладнені або надто формалізовані тест-фреймворки. Наприклад, JUnit — потужний інструмент, але його налаштування та вивчення займає час. Тому в цьому розділі ми не використовуватимемо ніяких зовнішніх фреймворків.

Натомість ми написатимемо дуже простий "тестовий фреймворк" на shell-скрипті, яким будемо користуватись протягом розробки.

Нижче наведено приклад shell-скрипта test.sh:

```shell
#!/bin/bash
assert() {
  expected="$1"
  input="$2"

  ./9cc "$input" > tmp.s
  cc -o tmp tmp.s
  ./tmp
  actual="$?"

  if [ "$actual" = "$expected" ]; then
    echo "$input => $actual"
  else
    echo "$input => $expected expected, but got $actual"
    exit 1
  fi
}

assert 0 0
assert 42 42

echo OK
```

Створіть файл **test.sh** з вмістом, наведеним вище, і зробіть його виконуваним за допомогою команди `chmod a+x test.sh`. Спробуйте запустити **test.sh**. Якщо не виникне жодних помилок, скрипт завершиться з відображенням **OK** наприкінці.

```shell
$ ./test.sh
0 => 0
42 => 42
OK
```

Якщо станеться помилка, **test.sh** не відобразить **OK**. Натомість **test.sh** покаже очікуване значення та фактичне значення для невдалого тесту у такому форматі:

```shell
$ ./test.sh
0 => 0
42 expected, but got 123
```

Якщо ви хочете налагодити тестовий скрипт, запустіть його в **bash** з опцією **-x**. З цією опцією **bash** відображатиме трасування виконання, як показано нижче.

```shell
$ bash -x test.sh
+ assert 0 0
+ expected=0
+ input=0
+ cc -o 9cc 9cc.c
+ ./9cc 0
+ cc -o tmp tmp.s
+ ./tmp
+ actual=0
+ '[' 0 '!=' 0 ']'
+ assert 42 42
+ expected=42
+ input=42
+ cc -o 9cc 9cc.c
+ ./9cc 42
+ cc -o tmp tmp.s
+ ./tmp
+ actual=42
+ '[' 42 '!=' 42 ']'
+ echo OK
OK
```

«Тестовий фреймворк», який ми будемо використовувати протягом цієї книги, — це звичайний шелл-скрипт, подібний до наведеного вище. Можливо, цей скрипт здасться надто простим у порівнянні з повноцінними тестовими фреймворками на кшталт JUnit, але така простота добре узгоджується з простотою самого 9cc, тому саме така легкість і є бажаною.

Суть автоматичного тестування полягає в тому, щоб можна було миттєво запустити свій код і автоматично порівняти результат. Тож не варто ускладнювати — головне, почати писати тести.

### Збірка за допомогою make

Протягом читання цієї книги вам доведеться зібрати **9cc** сотні або навіть тисячі разів. Оскільки процес створення виконуваного файлу 9cc і запуску тестового скрипта щоразу однаковий, зручно доручити цю роботу інструменту.

Стандартним інструментом для таких цілей є команда **make**.

Після запуску **make** читає файл з назвою **Makefile** у поточній директорії та виконує команди, записані в ньому.

Makefile складається з **правил**, що закінчуються двокрапкою, і **набору команд**, які виконуються для кожного правила.

Нижченаведений Makefile автоматизує команди, які ми хочемо виконувати на цьому етапі.

```Makefile
CFLAGS=-std=c11 -g -static

9cc: 9cc.c

test: 9cc
        ./test.sh

clean:
        rm -f 9cc *.o *~ tmp*

.PHONY: test clean
```

Створіть **файл з назвою Makefile** в тій самій директорії, де знаходиться **9cc.c**, використовуючи наведений вище вміст.

Після цього, достатньо буде просто виконати команду `make`, щоб зібрати **9cc**, а команду `make test` — щоб запустити тести.

**make** розуміє залежності між файлами, тому після зміни **9cc.c** немає потреби вручну запускати `make` перед `make test`. Якщо виконуваний файл **9cc** старіший за **9cc.c**, `make` автоматично збере **9cc** перед запуском тестів.

`make clean` — це правило для видалення тимчасових файлів. Хоча можна видалити ці файли вручну за допомогою `rm`, це небезпечно, оскільки можна випадково видалити щось важливе. Тому такі службові завдання теж зручно прописати у Makefile.

**Зверніть увагу**: в Makefile для відступів **обов’язково** використовуються **табуляції**, а не пробіли. Використання пробілів (навіть чотирьох або восьми) призведе до помилки. Це незручність пов’язана з тим, що `make` — дуже старий інструмент, розроблений ще в 1970-х роках.

Нарешті, компілятору `cc` **обов’язково** потрібно передавати опцію `-static`. Її призначення буде пояснено в розділі про динамічне лінкування. Наразі вам не потрібно вдаватися в деталі — просто включайте цю опцію завжди.

**Управління версіями за допомогою Git**

У цій книзі ми будемо використовувати **Git** як систему контролю версій. Оскільки компілятор створюється поступово, крок за кроком, створюйте **коміт у Git на кожному етапі** з відповідним **коментарем-коментарем (коміт-меседжем)**.

Коментарі до комітів можна писати **українською або японською** — головне, щоб вони чітко підсумовували зроблені зміни в **одному рядку**. Якщо ви хочете додати детальніше пояснення, зробіть **один порожній рядок після першого рядка**, а потім напишіть розгорнутий опис змін.

За допомогою Git необхідно **відстежувати лише ті файли, які ви створюєте вручну**. Наприклад, **згенеровані файли**, які з’являються після запуску 9cc, **не потрібно додавати в Git**, оскільки їх можна легко згенерувати знову тими ж командами.

Якщо ви включите такі файли до репозиторію, коміти стануть перевантаженими непотрібними змінами. Тому важливо **виключити тимчасові файли та файли резервного копіювання з відстеження Git**.

У Git для цього використовується спеціальний файл з назвою **`.gitignore`**, де ви вказуєте шаблони файлів, які слід ігнорувати.

Створіть файл **.gitignore** у тій самій директорії, де знаходиться **9cc.c**, і додайте до нього такі шаблони, щоб Git ігнорував тимчасові файли, резервні копії редактора тощо:

```
*~
*.o
tmp*
a.out
9cc
```

Якщо ви використовуєте Git вперше, вам потрібно вказати своє ім’я та електронну адресу, щоб Git міг зберігати ці дані в журналі комітів.

Нижче наведено приклад того, як автор налаштовує своє ім’я та email у Git. Замість них введіть свої власні дані:

```
$ git config --global user.name "Rui Ueyama"
$ git config --global user.email "ruiu@cs.stanford.edu"
```

Щоб створити коміт у Git, спочатку потрібно додати змінені файли за допомогою команди git add.

Оскільки цього разу ми створюємо перший коміт, спершу потрібно ініціалізувати Git-репозиторій за допомогою git init, а потім додати всі файли, створені до цього моменту, за допомогою git add.

```shell
$ git init
Initialized empty Git repository in /home/ruiu/9cc
$ git add 9cc.c test.sh Makefile .gitignore
```

Потім зафіксуйте його за допомогою git commit.

```shell
$ git commit -m "Створіть компілятор, який компілює одне ціле число"
```

Укажіть повідомлення коміту за допомогою опції `-m`. Без параметра `-m` **git** запустить редактор. Ви можете підтвердити, що фіксація була успішною, запустивши `git log -p` наступним чином:

```shell
$ git log -p
commit 0942e68a98a048503eadfee46add3b8b9c7ae8b1 (HEAD -> master)
Author: Rui Ueyama <ruiu@cs.stanford.edu>
Date:   Sat Aug 4 23:12:31 2018 +0000

    整数1つをコンパイルするコンパイラを作成

diff --git a/9cc.c b/9cc.c
new file mode 100644
index 0000000..e6e4599
--- /dev/null
+++ b/9cc.c
@@ -0,0 +1,16 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+int main(int argc, char **argv) {
+  if (argc != 2) {
...
```

Нарешті, давайте завантажимо git-репозиторій, який ми створили досі, на GitHub. Немає особливої ​​причини завантажувати на GitHub, але також немає причин не робити цього, і GitHub корисний для резервного копіювання вашого коду. Щоб завантажити на GitHub, створіть нове сховище (у цьому прикладі я створив сховище під назвою 9cc за допомогою користувача rui314) і додайте його як віддалений репозиторій за допомогою такої команди:

```shell
$ git remote add origin git@github.com:rui314/9cc.git
```

Після цього, коли ви виконуєте git push, вміст вашого репозиторію буде відправлено на GitHub. Після виконання `git push` відкрийте GitHub у браузері та переконайтеся, що ваш вихідний код завантажено.

На цьому створення компілятора на першому кроці завершено. Компілятор на цьому етапі є надто простою програмою, щоб її можна було назвати компілятором, але це гарна програма, яка містить усі елементи, необхідні для компілятора. Відтепер ми продовжуватимемо розширювати функції цього компілятора, і, хоча в це все ще важко повірити, ми розробимо з нього чудовий компілятор C. По-перше, насолоджуйтеся завершенням першого кроку.

> **Еталонна реалізація**
>
> [f722daaaae060611](https://github.com/rui314/chibicc/commit/f722daaaae0606115df4ace5a852da23c1a5b0f3)