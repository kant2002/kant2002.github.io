---
layout: page
title: Вступ у створення компілятора C для тих, хто хоче знати про низькорівневі речі
permalink: /compilers/chibicc
translation_source: https://www.ocf.berkeley.edu/~stefan/fun/chibicc.html
translation_source: https://www.sigbus.info/compilerbook
---


*Це переклад цієї [дуже чудової книги про будування компіляторів](https://www.sigbus.info/compilerbook)*

Rui Ueyama <ruiu@cs.stanford.edu>

2020-03-16

- [Вступ](#вступ)
  - [Умовні позначення, використані в цій книзі](#умовні-позначення-використані-в-цій-книзі)
  - [Середовище розробки передбачається в цій книзі](#середовище-розробки-передбачається-в-цій-книзі)
  - [Про автора](#про-автора)
- [Машинна мова та асемблер](#машинна-мова-та-асемблер)
  - [ЦП і пам'ять](#цп-і-память)
  - [Що таке асемблер?](#що-таке-асемблер)
  - [C та відповідна асемблерна програма](#c-та-відповідна-асемблерна-програма)
    - [Простий приклад](#простий-приклад)
    - [Приклад із викликом функції](#приклад-із-викликом-функції)
  - [Підсумки цього розділу](#підсумки-цього-розділу)
- [Створення мови рівня калькулятора](#створення-мови-рівня-калькулятора)
  - [Крок 1: Створення мови, що компілює лише одне ціле число](#крок-1-створення-мови-що-компілює-лише-одне-ціле-число)
  - [Крок 2: Створення компілятора який може додавати та віднімати](#крок-2-створення-компілятора-який-може-додавати-та-віднімати)
  - [Крок 3: Впровадження токенізатора](#крок-3-впровадження-токенізатора)
  - [Крок 4: Покращення повідомлень про помилки](#крок-4-покращення-повідомлень-про-помилки)
  - [Опис граматики та рекурсивний спусковий розбір](#опис-граматики-та-рекурсивний-спусковий-розбір)
    - [Представлення граматичної структури за допомогою деревоподібної структури](#представлення-граматичної-структури-за-допомогою-деревоподібної-структури)
    - [Визначення граматики за допомогою правил породження](#визначення-граматики-за-допомогою-правил-породження)
    - [Опис правил породження за допомогою BNF](#опис-правил-породження-за-допомогою-bnf)
    - [Прості правила породження](#прості-правила-породження)
    - [Вираження пріоритету операторів за допомогою правил породженння](#вираження-пріоритету-операторів-за-допомогою-правил-породженння)
    - [Правила породженння із рекурсією](#правила-породженння-із-рекурсією)
    - [Сінтаксічний аналіз через рекурсивний спуск](#сінтаксічний-аналіз-через-рекурсивний-спуск)
  - Stack machine
    - Stack machine concept
    - Compile to stack machine
    - How to create a stack machine on x86-64
  - Step 5: Create a language that can perform four arithmetic operations
  - Step 6: Unary plus and unary minus
  - Step 7: Comparison operators
    - Tokenizer changes
    - new grammar
    - Assembly code generation
- Separate compilation and linking
  - What is separate compilation?
    - Separate compilation and its necessity
    - The necessity of header files and their contents
    - link error
    - Declaration and definition of global variables
  - C standard library and archive files
  - Step 8: File splitting and Makefile changes
    - Split files
    - Makefile changes
- Functions and local variables
  - Step 9: One character local variable
    - Variable area on the stack
    - Tokenizer changes
    - Parser changes
    - lvalue and rvalue
    - How to load a value from any address
    - Code generator changes
    - Main function changes
  - Step 10: Multi-character local variables
  - Step 11: return statement
  - 1973 C compiler
  - Step 12: Add control constructs
  - Step 13: Block
  - Step 14: Respond to function calls
  - Step 15: Address the function definition
  - Binary level interface
- Representation of integers in computers
  - unsigned integer
  - signed integer
  - sign extension
  - Reversal of sign
- Pointers and string literals
  - Step 16: Unary &and Unary*
  - Step 17: Eliminate implicit variable definitions and introduce the int keyword
  - Step 18: Introducing pointer types
    - Define a type that represents a pointer
    - Assign to the value pointed to by the pointer
  - Step 19: Implement pointer addition and subtraction
  - Step 20: sizeof operator
  - Step 21: Implement the array
    - Define an array type
    - Implement implicit type conversion from array to pointer
  - Step 22: Implement array subscripting
  - Step 23: Implement global variables
  - Step 24: Implement the character type
  - Step 25: Implement string literals
  - Step 26: Read input from file
  - Step 27: Line and block comments
  - Step 28: Rewrite the test in C
- Program execution image and initialization formula
  - Executable file structure
  - Data segment contents
  - Initialization expression syntax
  - Global variable initialization expression
  - Local variable initialization expression
- After step 29: [Addition required]
- Static and dynamic links
  - static link
- C type syntax
  - Diagram representing the type
  - Notation for representing types
  - How to read C types
    - How to read non-nested types
    - How to read nested types
  - Exercises
- in conclusion
- Appendix 1: x86-64 Instruction Set Cheat Sheet
  - List of integer registers
  - memory access
  - function call
  - conditional branch
  - conditional assignment
  - Integer/logical operations
- Appendix 2: Version control with Git
  - Workflow using Git
  - Points to note when committing
  - Internal structure of Git
- Appendix 3: Creating a development environment using Docker
  - Setup steps
  - Build using containers
  - Add new application to container
- Reference materials
- index

# Вступ

Ця онлайн-книга зараз пишеться. Це не остаточна версія. [форма зворотного зв'язку](https://goo.gl/forms/DWmgm5fChpJ6IEFI3)

Ця книга наповнена вмістом, який занадто багато, щоб включити в одну книгу. У цій книзі ми створимо програму, яка перетворює вихідний код, написаний мовою Сі, на мову асемблера, тобто компілятор Сі. Сам компілятор також розроблено з використанням C. Найближчою метою є можливість самостійного розміщення, тобто компіляції власного вихідного коду за допомогою домашнього компілятора.

У цій книзі я вирішив пояснити різні теми в прогресивній манері, щоб не ускладнювати пояснення компіляторів. Ось чому:

Концептуально компілятори можна розділити на кілька етапів: аналіз, проміжні проходи та генерація коду. Загальний підхід у підручниках полягає в тому, щоб пояснювати кожну тему розділами, але книги з таким підходом, як правило, стають занадто вузькими та глибокими посередині, що ускладнює для читачів слідування.

Крім того, за допомогою методу розробки для створення кожного етапу неможливо запустити компілятор, доки не будуть завершені всі етапи, тому важко помітити, чи є певна помилка у вашому розумінні чи коді, доки весь етап не почне працювати. Недоліком є ​​те, що ви не можете. По-перше, ви насправді не знаєте, якими будуть вхідні дані наступного етапу, доки ви не створите його самі, тому ви насправді не знаєте, що виводити на попередньому етапі. Інша проблема полягає в тому, що важко залишатися мотивованим, оскільки ви не можете скомпілювати жодного коду, поки він не буде завершений.

У цій книзі я вирішив застосувати інший підхід, щоб уникнути цієї пастки. На початку книги ви реалізуєте ``власну мову'' з дуже простою специфікацією мови. Мова настільки проста, що вам не потрібно багато знати про те, як написати компілятор для її реалізації. Після цього читач продовжуватиме додавати функції до «власної мови» за допомогою цієї книги, і зрештою розвине її до чогось, що сумісно з C.

У такому методі інкрементальної розробки ви створюєте компілятор крок за кроком, роблячи невеликі коміти. За допомогою цього методу розробки компілятор завжди в якомусь сенсі «завершений» при кожному коміті. На одному етапі це може бути лише рівень калькулятора, на іншому це може бути дуже обмежена підмножина C, а на іншому це може бути мова, яку майже можна назвати C. Справа в тому, що на кожному етапі ми прагнемо до мови з прийнятними специфікаціями, які відповідають рівню завершеності на цьому етапі. Під час розробки ми не наголошуємо лише на деяких функціях, щоб це виглядало як мова C.

Ми також пояснимо структури даних, алгоритми та знання з інформатики поетапно відповідно до стадії розробки.

Поступовий розвиток досягає мети, щоб у будь-який момент часу під час читання цієї книги читач мав повне знання про те, як створити розумну мову на цьому рівні. Це набагато краще, ніж стан, коли лише деякі теми створення компілятора надзвичайно детальні. До того часу, коли ви закінчите читати цю книгу, ви будете добре обізнані з усіма темами.

Ця книга також пояснює, як писати великі програми з нуля. Уміння створювати великі програми - унікальне вміння, яке відрізняється від вивчення структур даних і алгоритмів, але я не думаю, що існує багато книг, які пояснюють такі речі. Крім того, навіть якщо хтось пояснить вам це, ви не знатимете, чи є метод розробки хорошим чи поганим, якщо ви не випробували його насправді. Ця книга розроблена таким чином, що процес розробки вашої власної мови на мову C дасть вам практичний досвід хорошого методу розробки.

Якщо план автора вдасться, прочитавши цю книгу, читачі не тільки дізнаються про техніку створення компіляторів і набору інструкцій центрального процесора, а й дізнаються, як розбивати великі програми на маленькі кроки і створювати їх потроху. Ви дізнаєтесь про методи тестування, методи контролю версій і навіть про те, як підготуватися до такого амбітного проекту, як написання компілятора.

Цільова аудиторія цієї книги - звичайні програмісти на C. Вам не потрібно бути суперпрограмістом на C, який добре знає специфікацію мови C. Достатньо, щоб ви розбиралися в покажчиках і масивах і могли принаймні приділити трохи часу читанню невеликих програм C, написаних іншими.

Під час написання цієї книги я намагався не лише пояснити специфікації мови та специфікації процесора, але й якомога докладніше пояснити, чому було обрано саме такий дизайн. Ми також включили колонки про компілятори, центральні процесори, комп’ютерну індустрію та її історію, які зацікавлять читачів і зроблять її читанням приємним.

Створення компілятора - це дуже весело. На початку моя саморобна мова могла робити лише неймовірно прості речі, але, продовжуючи її розвивати, вона швидко стала нагадувати мову C настільки, що навіть я був здивований, і вона почала працювати, наче за помахом чарівної палички. стати. Під час фактичної розробки я часто дивуюся тому, що великий тестовий код, який, на мою думку, не буде добре скомпільований у той час, компілюється без помилок і працює ідеально правильно. Такий код нелегко зрозуміти самому, навіть дивлячись на скомпільовану збірку. Іноді я навіть відчуваю, що мій компілятор має більше розуму, ніж я, автор. Компілятор - це програма, яка, навіть якщо ви знаєте, як вона працює, все одно дивуєтеся, чому вона працює так добре. Я впевнений, що ви теж закохаєтесь у його чарівність.

Отже, без зайвих слів, давайте разом з автором стрибнемо у світ розробки компілятора!

> **Стаття: Чому мова C?**
> 
> Чому серед багатьох доступних мов програмування ви вибрали C для цієї книги? Або чому б не рідна мова? Стосовно цього моменту немає жодних причин, чому це обов’язково має бути C, але якщо вам потрібно вибрати мову, щоб навчитися створювати компілятор, який виводить рідний код, C є розумним вибором, який не дуже поширений. Я думаю, що це один із них.
> 
> Інтерпретовані мови не дозволяють дізнатися багато про нижчі рівні. З іншого боку, C зазвичай компілюється в асемблер, тому, створивши компілятор, ви можете дізнатися про набір інструкцій процесора та роботу програм, а також про сам C.
> 
> C широко використовується, тому, коли у вас є робочий компілятор, ви можете пограти з компіляцією стороннього вихідного коду, який ви завантажуєте з Інтернету. Наприклад, ви можете зібрати та грати в mini Unix xv6. Якщо компілятор достатньо зрілий, можна буде скомпілювати навіть ядро ​​Linux. Така насолода неможлива з другорядними або доморощеними мовами.
> 
> C++ - це статично типізована мова, яка компілюється до рідної машинної мови, як-от C, і використовується принаймні так само широко, як і C. Однак специфікації мови для C++ настільки великі, що неможливо легко створити власний компілятор, тому це нереалістичний варіант.
> 
> Розробка та реалізація оригінальної мови - це добре з точки зору вдосконалення відчуття мовного дизайну, але є й підводні камені. Речі, які важко реалізувати, можна уникнути, уникаючи їх у специфікації мови. Це не стосується таких мов, як C, де специфікація мови дається як стандарт. Я вважаю, що це обмеження досить добре з точки зору навчання.

## Умовні позначення, використані в цій книзі

Функції, вирази, команди тощо відображаються в тексті моноширинним шрифтом, наприклад, `main`, `foo=3`, `make`.

Код, який охоплює кілька рядків, відображається у рамці за допомогою моноширинного шрифту, як показано нижче.

```c
int main() {
  printf("Hello world!\n");
  return 0;
}
```

Якщо рамковий код є командою оболонки, яку користувач має дослівно ввести, рядок $, що починається з, представляє підказку. $Введіть решту цього рядка ($але не решту) в оболонку. $Інші рядки представляють результат введеної вами команди. Наприклад, блок нижче make є прикладом того, що відбувається, коли користувач вводить рядок `make` і натискає Enter. Результатом команди є `make: Nothing to be done for 'all'`:

## Середовище розробки передбачається в цій книзі

У цій книзі передбачається, що 64-розрядне середовище Linux працює на так званому звичайному ПК, такому як Intel або AMD. Будь ласка, інсталюйте інструменти розробки, такі як gcc, і створіть заздалегідь відповідно до дистрибутива, який ви використовуєте. Якщо ви користуєтеся Ubuntu, ви можете встановити команди, які використовуються в цій книзі, виконавши таку команду.

```shell
$ sudo apt update
$ sudo apt install -y gcc make git binutils libc6-dev
```

Хоча macOS досить сумісна з Linux на рівні джерела збірки, вона не є повністю сумісною (зокрема, функція під назвою «статичне зв’язування» не підтримується). Хоча можна створити компілятор C для macOS, використовуючи інформацію з цієї книги, якщо ви спробуєте це, ви, ймовірно, зіткнетеся з низкою незначних несумісностей. Не рекомендується одночасно вивчати прийоми створення компілятора C і відмінності між macOS і Linux. Коли щось не працює, важко зрозуміти, яке розуміння неправильне.

Тому ця книга не стосується macOS. У macOS використовуйте якесь віртуальне середовище, щоб підготувати середовище Linux. Якщо ви вперше готуєте віртуальне середовище Linux, зверніться до [Додатку 3](#), у якому підсумовано, як створити середовище розробки за допомогою Docker.

Windows не сумісна з Linux на рівні джерела складання. Однак у Windows 10 можна запускати Linux у Windows як одну програму, і, використовуючи це, ви можете продовжувати розробку у Windows. Програма під назвою Windows Subsystem for Linux (WSL) є таким Linux-сумісним середовищем. Впроваджуючи вміст цієї книги в Windows, інсталюйте WSL і продовжуйте розробку в ньому.

> **Стаття: крос-компілятор**
> 
> Машина, на якій працює компілятор, називається «хостом», а машина, на якій виконується код, виведений компілятором, називається «цільовою». Хоча в цій книзі обидва є 64-розрядними середовищами Linux, хост і ціль не обов’язково повинні бути однаковими.
> 
> Компілятор, хост і ціль якого відрізняються, називається крос-компілятором. Наприклад, компілятор, який працює в Windows і створює виконуваний файл для Raspberry Pi, є крос-компілятором. Крос-компілятори часто використовуються, коли цільова машина занадто слабка або спеціалізована для запуску компілятора.

## Про автора

Руї Уеяма ( [@rui314](https://twitter.com/rui314) ). Він є оригінальним автором і поточним супроводжувачем високошвидкісного компонувальника lld, який використовується як стандартний компонувальник для створення виконуваних файлів у багатьох ОС і проектах, включаючи Android (версія Q або новіша), FreeBSD (12 або новіша), Nintendo Switch, Chrome і Firefox. (Отже, існує висока ймовірність того, що двійковий файл, створений інструментом, який я написав, уже є на вашому комп’ютері.) Він також є автором компактного компілятора C [8cc](https://github.com/rui314/8cc). В основному я пишу есе про програмне забезпечення в [нотатках](https://note.mu/ruiu).

> **Стаття: компілятор, який компілює компілятор**
> 
> Ситуації з самопосиланням, такі як компілятор C, написаний мовою C, не є рідкістю. Багато реалізацій мови, крім C, написані з використанням самої мови.
> 
> Якщо вже існує реалізація мови X, немає ніяких логічних протиріч у створенні нового компілятора X за допомогою самої мови. Якщо ви вирішите самостійно розміщувати компілятор, ви можете просто розробляти його за допомогою існуючого компілятора, а коли закінчите, переключитися на свій власний. Саме це ми намагаємося зробити в цій книзі.
> 
> Але що, якщо у вас немає наявного компілятора? У такому випадку у вас немає іншого вибору, як писати іншою мовою. Під час написання вашого першого компілятора для мови X з наміром самостійного розміщення вам потрібно буде написати його за допомогою існуючої мови Y, яка відрізняється від X, і коли компілятор буде завершено, вам потрібно буде переписати сам компілятор з мови Y на мову X.
> 
> Компілятори для сучасних складних мов програмування також є іншими компіляторами, які використовувалися для компіляції реалізацій цієї мови, і так далі, поки на початку комп’ютерів хтось не зміг безпосередньо написати машинний код. Ви повинні отримати простий асемблер, який ви написали. Ми не знаємо, чи існував один або кілька асемблерів, які в певному сенсі є основними предками всіх існуючих реалізацій мови, але немає сумніву, що сучасні компілятори починалися з дуже невеликої кількості предків. Шо. Виконувані файли, крім компіляторів, також зазвичай генеруються компіляторами, тому майже всі існуючі виконувані файли є непрямими нащадками вихідного асемблера. Це цікава історія, схожа на походження життя.

---

# Машинна мова та асемблер

Мета цього розділу - дати вам приблизне уявлення про компоненти, з яких складається комп’ютер, і про те, який код ми повинні виводити з компілятора C, який ми створюємо. Ми поки не будемо вдаватися в особливості інструкцій ЦП. По-перше, важливо зрозуміти концепцію.

## ЦП і пам'ять

Компоненти, з яких складається комп’ютер, можна умовно розділити на центральний процесор і пам’ять. Пам'ять - це пристрій, який може зберігати дані, а центральний процесор - це пристрій, який читає та записує цю пам'ять для виконання певної обробки.

Концептуально, пам'ять виглядає для центрального процесора як великий масив байтів, до якого можна отримати довільний доступ. Коли центральний процесор звертається до пам’яті, він визначає, до якого байту пам’яті він хоче отримати доступ, вказуючи число, і це число називається «адресою». Наприклад, «прочитати 8 байт даних з адреси 16» означає зчитування 8 байт даних, починаючи з 16-го байта пам’яті, який виглядає як масив байтів. Те саме можна сказати як «прочитати 8 байт даних з адреси 16».

У пам’яті зберігаються як програми, які виконує ЦП, так і дані, які ці програми читають і записують. Центральний процесор зберігає адресу інструкції, що виконується в даний момент, зчитує інструкцію з цієї адреси, виконує те, що там записано, а потім читає та виконує наступну інструкцію. Адреса інструкції, що виконується в даний момент, називається «Лічильником програми» (PC) або «Покажчиком інструкції» (IP). Фактичний формат програми, яку виконує центральний процесор, називається «машинним кодом».

Лічильник програм не обов'язково лінійно переходить до наступної інструкції. Тип інструкції центрального процесора, який називається «інструкція розгалуження», дозволяє встановити лічильник програм на будь-яку адресу, окрім наступної інструкції. Ця функція дозволяє реалізувати оператори if, цикли тощо. Встановлення лічильника програм у місце, відмінне від наступної інструкції, називається «стрибком» або «розгалуженням».

Крім лічильника програм, центральний процесор також має невелику кількість областей зберігання даних. Наприклад, процесори Intel і AMD мають 16 розташувань, які можуть зберігати 64-розрядні цілі числа. Ця область називається «реєстр». Пам'ять є зовнішнім пристроєм центрального процесора, і для читання та запису в неї потрібен деякий час, але регістри знаходяться всередині центрального процесора, і до них можна отримати доступ без затримки.

Більшість машинних кодів відформатовано таким чином, що деякі операції виконуються з використанням значень двох регістрів, а результат записується назад у регістр. Таким чином, виконання програми передбачає зчитування ЦП даних із пам’яті в регістр, виконання якогось обчислення між регістрами та запис результату назад у пам’ять.

Конкретна інструкція машинної мови разом називається «архітектурою набору інструкцій» (ISA) або «набором інструкцій». Існує не лише один тип набору інструкцій; кожен ЦП може створювати його як завгодно. Однак, оскільки ту саму програму неможливо запустити без сумісності на рівні машинного коду, існує не так багато варіацій у наборах інструкцій. Комп’ютери використовують набір інструкцій під назвою x86-64, розроблений компанією Intel та її виробником сумісних мікросхем AMD. Хоча x86-64 є одним із основних наборів інструкцій, він не домінує на ринку. Наприклад, iPhone і Android використовують набір інструкцій під назвою ARM.

> Стаття: імена набору інструкцій x86-64
> 
> x86-64 також іноді називають AMD64, Intel 64, x64 тощо. Існує історична причина, чому той самий набір інструкцій має кілька таких назв.
> 
> Набір інструкцій x86 був створений Intel у 1978 році, але AMD розширила його до 64-розрядного. Приблизно в 2000 році, коли виникла потреба в 64-розрядних процесорах, Intel була прихильна до абсолютно нового набору інструкцій під назвою Itanium і не потрудилася вирішувати конкуруючу 64-розрядну версію x86. Скориставшись цією можливістю, AMD сформулювала та випустила специфікацію 64-bit x86. Це x86-64. Пізніше AMD перейменувала x86-64 на AMD64, можливо, як стратегію брендингу.
> 
> Після цього провал Itanium став очевидним, і Intel не мала іншого вибору, окрім як створити 64-розрядну версію x86. Однак на той час було випущено досить багато чіпів AMD64, тому було важко розробити розширений набір інструкцій, який був би схожим, але не ідентичним, і Intel вирішила прийняти набір інструкцій, сумісний з AMD. Кажуть, що Microsoft також чинила тиск з метою підтримки сумісності. У той час Intel прийняла набір інструкцій, який був майже ідентичний AMD64, і назвала його IA-32e. Той факт, що його назвали IA-32e (розширення Intel Architecture 32) замість 64, здається, показує тривалу прихильність до невдалого набору інструкцій, оскільки Itanium все ще є основою 64-розрядних процесорів. Тоді Intel вирішила повністю відмовитися від Itanium, і IA-32e було перейменовано на більш традиційну Intel 64. Microsoft називає x86-64 x64, можливо тому, що їм не подобаються надто довгі імена.
> 
> Ось чому x86-64 має так багато різних назв.
> 
> Проекти з відкритим кодом часто віддають перевагу назві x86-64, яка не містить назв конкретних компаній. У цій книзі постійно використовується назва x86-64.

## Що таке асемблер?

Оскільки машинний код зчитується безпосередньо ЦП, він призначений лише для зручності ЦП, а не для простоти використання людьми. Написання такого типу машинного коду в двійковому редакторі є дуже складним завданням, хоча це й не неможливо. Тому і був винайдений асемблер. Асемблювання - це мова, яка майже однозначно відповідає машинному коду, але її набагато легше читати людям.

Для компіляторів, які виводять власні двійкові файли (на відміну від віртуальної машини чи інтерпретатора), метою зазвичай є виведення асамблеї. Типовий компілятор, який, здається, безпосередньо виводить машинний код, виведе збірку, а потім запустить асемблер у фоновому режимі. Компілятор C, який ми створимо в цій книзі, також виводить збірку.

Перетворення асемблерного коду в машинний код іноді називають «компіляцією», але іноді його також називають «ассемблером», щоб підкреслити, що вхідні дані є асамблеєю.

Можливо, ви вже десь бачили збірку. Якщо ви ще не бачили збірку, зараз саме час подивитися. Давайте скористаємося командою `objdump`, щоб розібрати виконуваний файл і відобразити машинний код, що міститься в ньому, як код складання. Нижче наведено результат розбирання команди `ls`.

```
$ objdump -d -M intel /bin/ls
/bin/ls:     file format elf64-x86-64

Disassembly of section .init:

0000000000003d58 <_init@@Base>:
  3d58:  48 83 ec 08           sub    rsp,0x8
  3d5c:  48 8b 05 7d b9 21 00  mov    rax,QWORD PTR [rip+0x21b97d]
  3d63:  48 85 c0              test   rax,rax
  3d66:  74 02                 je     366a <_init@@Base+0x12>
  3d68:  ff d0                 call   rax
  3d6a:  48 83 c4 08           add    rsp,0x8
  3d6e:  c3                    ret
...
```

У моєму середовищі команда `ls` містить близько 20 000 машинних інструкцій, тому дизассемблований результат також досить довгий, майже 20 000 рядків. Ми включили лише перші кілька сюди.

Код складання зазвичай структурований як один рядок на машинний код. Наприклад, розглянемо такий рядок:

```
  3d58:  48 83 ec 08           sub    rsp,0x8
```

Що означає цей рядок? `3d58` - це адреса пам'яті, яка містить машинний код. Це означає, що під час виконання команди ls інструкції в цьому рядку будуть розміщені в пам’яті за адресою `0x3d58` і виконуватимуться, коли програмний лічильник буде `0x3d58`. Наступні чотири шістнадцяткові числа є фактичним машинним кодом. ЦП зчитує ці дані та виконує їх як інструкції. `sub rsp,0x8` - збірка, яка відповідає цій машинній інструкції. Набір інструкцій центрального процесора буде пояснено в окремій главі, але ця інструкція віднімає 8 з регістру під назвою RSP.

# C та відповідна асемблерна програма

## Простий приклад

Щоб отримати уявлення про те, який саме вивід генерує C-компілятор, порівняймо C-код із відповідним йому асемблерним кодом. Розглянемо найпростіший приклад - наступну програму на C:

```c
int main() {
  return 42;
}
```

Припустимо, що ця програма записана у файл `test1.c`. Її можна скомпілювати таким чином і перевірити, що вона дійсно повертає значення 42:

```shell
$ cc -o test1 test1.c
$ ./test1
$ echo $?
42
```

У C значення, яке повертає функція `main`, стає кодом завершення всієї програми. Цей код завершення не виводиться на екран, але неявно зберігається у змінній оболонки `$?`, тож одразу після завершення команди можна вивести значення цієї змінної командою `echo $?`. Тут ми бачимо, що було повернуто саме `42`.

Асемблерна програма, що відповідає цій C-програмі, виглядає наступним чином:

```asm
.intel_syntax noprefix
.globl main
main:
        mov rax, 42
        ret
```

У цьому асемблері оголошено глобальну мітку `main`, після якої йде код функції. Значення 42 записується в регістр `RAX`, і потім здійснюється повернення з функції. Існує загалом 16 регістрів, які можуть містити цілі числа, включаючи `RAX`. За домовленістю, значення, яке знаходиться в `RAX` після повернення з функції, вважається її результатом. Тому в цьому випадку число 42 записується саме в `RAX`.

Спробуймо скомпілювати й виконати цю асемблерну програму. Файл з асемблерним кодом має розширення `.s`, тож запишіть наведений вище код у файл `test2.s` і виконайте наступні команди:

```shell
$ cc -o test2 test2.s
$ ./test2
$ echo $?
42
```

Як і у випадку з C-програмою, результатом виконання програми став код завершення 42.

Грубо кажучи, C-компілятор - це програма, яка зчитує C-код, такий як у `test1.c`, і генерує асемблерний код на кшталт `test2.s`.

## Приклад із викликом функції

Розглянемо трохи складніший приклад, у якому показано, як код із викликом функції перетворюється на асемблер.

Виклик функції - це не просто **перехід** (*jump*); після завершення викликаної функції програма повинна повернутися до місця, з якого цей виклик був зроблений. Адресу, за якою потрібно відновити виконання, називають **адресою повернення** (*return address*). Якщо виклик функції здійснюється лише один раз, цю адресу можна зберегти в якомусь реєстрі процесора. Але оскільки функції можуть викликатися рекурсивно або вкладено будь-яку кількість разів, адресу повернення потрібно зберігати в пам’яті - конкретно у **стеку**.

Стек можна реалізувати, використовуючи лише одну змінну, яка зберігає адресу його вершини. Ця змінна зберігається у спеціальному регістрі, що називається **стековим вказівником** (*stack pointer*). Архітектура x86-64 підтримує роботу з функціями, маючи спеціальний регістр стекового вказівника та відповідні інструкції. Занесення даних у стек називається **пуш** (*push*), а зняття даних зі стека - **поп** (*pop*).

**Розглянемо приклад на C:**
```c
int plus(int x, int y) {
  return x + y;
}

int main() {
  return plus(3, 4);
}
```
Відповідний асемблерний код виглядає так:

```asm
.intel_syntax noprefix
.globl plus, main

plus:
        add rsi, rdi
        mov rax, rsi
        ret

main:
        mov rdi, 3
        mov rsi, 4
        call plus
        ret
```

1-й рядок вказує на використання Intel-синтаксису. 2-й рядок з `.globl` оголошує функції `plus` і `main` як глобальні, тобто видимі в усій програмі. Це можна тимчасово проігнорувати.

Зосередимось на функції `main`. У C вона викликає `plus` з аргументами. У асемблері є правило: перший аргумент передається через регістр `RDI`, другий - через `RSI`. Тому перші два рядки функції `main` присвоюють значення 3 і 4 цим реєстрам відповідно.

Інструкція `call` викликає функцію. Вона виконує два кроки:

1. Заносить адресу наступної інструкції (`ret`)` у стек - це і є адреса повернення.
2. Переходить до функції, вказаної як аргумент (у цьому випадку - `plus`).

**Функція `plus`**

Функція `plus` складається з трьох інструкцій.

- `add rsi, rdi`: додає значення в `rdi` до `rsi` і зберігає результат у `rsi`. У x86-64 арифметичні інструкції зазвичай працюють із двома операндами, де результат зберігається в першому.
- `mov rax, rsi`: копіює результат із `rsi` у `rax`, оскільки значення, яке повертається з функції, повинно бути в регістрі `RAX`.
- `ret`: ця інструкція:
  1. Знімає зі стека адресу повернення.
  2. Переходить за цією адресою.

Іншими словами, `ret` є зворотною операцією до `call`, і разом вони забезпечують правильну передачу керування між функціями.

Після повернення з `plus`, керування знову опиняється в `main`, а значення в `rax` уже є результатом виклику функції `plus`. Тому інструкція `ret` в `main` повертає це саме значення - як і в оригінальному коді на C.

# Підсумки цього розділу

У цьому розділі ми стисло пояснили, як комп’ютер працює «під капотом» і що саме має робити C‑компілятор. Коли дивишся на асемблер чи машинний код, вони здаються громіздкими й далекими від C, проте, як виявилося, їхня структура доволі прямо відображає ту саму логіку, що й у C‑коді - це, мабуть, помітили багато читачів.

Оскільки в книжці ми ще майже не розглядали конкретні машинні інструкції, значення окремих команд асемблера, показаних через objdump, можуть бути незрозумілими. Та й не потрібно їх одразу знати напам’ять: важливо лише відчути, що кожна інструкція сама по собі робить небагато. На цьому етапі такого інтуїтивного розуміння цілком достатньо.

Нижче наведено ключові моменти розділу у вигляді тез:

- **CPU виконує програму, читаючи й записуючи дані до пам’яті.**
- **І сам виконуваний код, і дані, з якими він працює, зберігаються в оперативній пам’яті;** процесор послідовно зчитує з неї машинні інструкції та виконує їх.
- **У CPU є невеликі комірки пам’яті - реєстри**, і більшість машинних інструкцій описує саме операції між реєстрами.
- **Асемблер - це «читабельна» форма машинного коду**, і типовий C‑компілятор передусім генерує саме асемблерний текст.
- **Функції в C залишаються функціями й в асемблері;** їхні межі та виклики чітко зберігаються.
- **Виклик функцій реалізовано через стек**, де зберігаються адреси повернення та інші дані, потрібні для коректного відновлення виконання.

> **Колонка: Онлайн-компілятор**
> 
> Спостерігати за C‑кодом і результатом його компіляції - чудовий спосіб вивчати асемблерну мову. Але постійно редагувати вихідний код, компілювати його і вручну переглядати асемблерний вивід - це доволі клопіткий процес.
> 
> На щастя, існує дуже зручний вебсайт, який значно спрощує цю задачу - [Compiler Explorer](https://godbolt.org/z/RyNqgE) (відомий також як godbolt). На цьому сайті, якщо ввести C‑код у текстове поле на лівій половині екрана, то в правій половині миттєво з’являється відповідний асемблерний код.
> 
> Коли хочете швидко перевірити, у що саме перетворюється ваш C‑код, цей сервіс стане надзвичайно корисним.

# Створення мови рівня калькулятора

У цьому розділі, як перший крок до створення компілятора C, ми реалізуємо підтримку чотирьох основних арифметичних операцій та інших арифметичних операторів, щоб мати змогу компілювати вирази на кшталт:

```
30 + (4 - 2) * -5
```

На перший погляд, це може здаватися простим завданням, але насправді воно досить складне. У математичних виразах існує структура: наприклад, вирази в дужках мають вищий пріоритет, множення має вищий пріоритет за додавання тощо. Якщо не зрозуміти цю структуру належним чином, обчислення буде неправильним. Проте вхідний вираз - це всього лише плоска послідовність символів, а не структуровані дані. Щоб правильно оцінити вираз, потрібно проаналізувати послідовність символів і вивести приховану в ній структуру.

Такі задачі синтаксичного аналізу дуже складно розв’язати без попередніх знань. У минулому, особливо в період з 1950-х по 1970-ті роки, ці задачі вважалися складними, і над ними активно працювали, розробляючи різноманітні алгоритми. Завдяки тим зусиллям сьогодні синтаксичний аналіз уже не є настільки складною задачею, якщо знати, як до неї підходити.

У цьому розділі ми пояснимо один з найпоширеніших алгоритмів синтаксичного аналізу - парсер рекурсивного спуску  (recursive descent parsing). Цей метод використовують компілятори C/C++, якими ви, ймовірно, користуєтеся щодня, такі як GCC і Clang.

Потреба аналізувати текст із певною структурою виникає не лише при створенні компіляторів, а й у багатьох інших ситуаціях програмування. Техніки, які ви вивчите в цьому розділі, можна застосовувати і до таких задач. Без перебільшення можна сказати, що методи синтаксичного аналізу, які ми розглянемо, - це інструменти на все життя. Прочитайте цей розділ, зрозумійте алгоритм і додайте техніку синтаксичного аналізу до вашої програмістської скарбнички навичок.

## Крок 1: Створення мови, що компілює лише одне ціле число

Розгляньмо найпростіший можливий підмножину мови C. Якою мовою ви її уявляєте? Мовою, що містить лише функцію main? Або мовою, яка складається лише з одного виразу? Якщо звести все до абсолютного мінімуму, можна сказати, що мова, яка складається лише з одного цілого числа, є найпростішим можливим підмножиною.

У цьому кроці ми реалізуємо саме таку - найпростішу - мову.

Програма, яку ми створимо на цьому етапі, буде компілятором, що зчитує одне число з вхідних даних і генерує асемблерний код, який завершує виконання програми з цим числом як кодом завершення. Іншими словами, якщо вхідні дані - це просто рядок, наприклад 42, то компілятор має вивести такий асемблерний код:

```asm
.intel_syntax noprefix
.globl main

main:
        mov rax, 42
        ret
```

Рядок `.intel_syntax noprefix` - це директива асемблера, яка вказує, що ми використовуємо стиль Intel для запису асемблерного коду (існує кілька стилів, і цей - той, який використовується в цій книзі). У компіляторі, який ви створюєте, завжди додавайте цей рядок на початку як стандартну частину виводу. Інші рядки - ті самі, що ми вже пояснювали в попередньому розділі.

Можливо, дехто з читачів подумає: "Такий простий програмний код - хіба це компілятор?" Чесно кажучи, автор теж так думає. Але з технічної точки зору, ця програма приймає на вхід мову, що складається з одного цілого числа, і генерує відповідний машинний код - отже, за визначенням, це цілком справжній компілятор. І навіть така проста програма стане основою, яку ми зможемо поступово ускладнювати, тож почати з неї - слушне рішення.

Насправді, якщо дивитися на загальну структуру процесу розробки, цей крок є дуже важливим. Саме цей базовий компілятор ми будемо використовувати як скелет для подальшого розвитку. На цьому етапі ми не лише створимо ядро компілятора, а й налаштуємо файл збірки (Makefile), автоматичне тестування і репозиторій Git. Давайте розглянемо кожен із цих процесів по черзі.

До речі, компілятор, який ми створюємо в цій книзі, має назву 9cc. cc - це загальноприйнята абревіатура для "C compiler". Число 9 особливого значення не має - попередня версія компілятора, створена автором, мала назву 8cc, тож 9cc - це наступна ітерація. Звісно, ви можете вибрати будь-яку назву для власного компілятора. Головне - не витрачайте надто багато часу на вибір назви і не відкладайте через це саму розробку. Назву, включно з назвою репозиторію на GitHub, завжди можна змінити пізніше, тому почніть із чогось простого.

> **Колонка: Нотація Intel та AT&T**
> 
> Окрім Intel-нотації, яка використовується в цій книзі, існує також AT&T-нотація, що широко застосовується в Unix-системах. Наприклад, gcc та objdump за замовчуванням виводять асемблерний код саме в AT&T-нотації.
> 
> В AT&T-нотації результат записується як другий аргумент інструкції. Це означає, що в командах з двома аргументами порядок аргументів буде обернений порівняно з Intel-нотацією. Крім того:
> 
> Імена регістрів починаються з префікса `%`, наприклад `%rax`.
> 
> Числові значення мають префікс `$`, наприклад `$42`.
> 
> Для доступу до пам’яті замість квадратних дужок `[]` використовуються круглі `()`, і синтаксис має свій особливий вигляд.
> 
> Нижче наведено кілька прикладів для порівняння:

```asm
mov rbp, rsp            // Intel
mov %rsp, %rbp          // AT&T

mov rax, 8              // Intel
mov $8, %rax            // AT&T

mov [rbp + rcx * 4 - 8], rax     // Intel
mov %rax, -8(rbp, rcx, 4)        // AT&T
```
> 
> У цьому компіляторі ми обрали Intel-нотацію, оскільки вона є читабельнішою, особливо для новачків. Крім того, офіційна документація Intel щодо інструкцій також використовує саме цей стиль, що дозволяє легко переносити приклади з мануалів без перетворення.
> 
> Щодо виразності обох нотацій - вона абсолютно однакова. Яку б нотацію ви не використали, згенерований машинний код буде ідентичним.

### Створення ядра компілятора

Зазвичай компілятор отримує вхідні дані у вигляді файлу, але на цьому етапі, щоб не ускладнювати задачу відкриттям і зчитуванням файлів, ми передаватимемо код безпосередньо як перший аргумент командного рядка.

C-програму, яка зчитує це значення як число, і вбудовує його в стандартну структуру асемблерного коду, можна написати дуже просто. Вона буде виглядати приблизно так:

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv) {
  if (argc != 2) {
    fprintf(stderr, "Неправильна кількість аргументів.\n");
    return 1;
  }

  printf(".intel_syntax noprefix\n");
  printf(".globl main\n");
  printf("main:\n");
  printf("  mov rax, %d\n", atoi(argv[1]));
  printf("  ret\n");
  return 0;
}
```

Створіть порожній каталог із назвою `9cc`, і в ньому створіть файл `9cc.c`, який міститиме програму, описану вище. Після цього спробуйте виконати `9cc` з командного рядка, як показано нижче, щоб перевірити, чи програма працює належним чином.

```shell
$ cc -o 9cc 9cc.c
$ ./9cc 123 > tmp.s
```

У першому рядку ми компілюємо файл `9cc.c` і створюємо виконуваний файл з назвою `9cc`. У другому рядку ми передаємо число `123` як вхідний аргумент програмі `9cc`, яка генерує асемблерний код і записує його у файл `tmp.s`.

Давайте перевіримо вміст файлу `tmp.s`, щоб переконатися, що все працює правильно.

```shell
$ cat tmp.s
.intel_syntax noprefix
.globl main
main:
  mov rax, 123
  ret
```

Як бачите, асемблерний код було успішно згенеровано. Тепер ми можемо передати цей асемблерний файл асемблеру, щоб створити виконуваний файл.

У системах Unix команда `cc` (або `gcc`) слугує не лише компілятором C чи C++, а й універсальним інтерфейсом (фронтендом) до багатьох мов. Вона визначає мову за розширенням вхідного файлу і автоматично викликає відповідний компілятор або асемблер. Тому, як і у випадку компіляції `9cc.c`, якщо ми передамо асемблерний файл з розширенням `.s` до `cc`, він його засемблює.

Нижче наведено приклад, як виконується асемблювання, запуск програми та перевірка коду завершення:

```shell
$ cc -o tmp tmp.s
$ ./tmp
$ echo $?
123
```

У Unix оболонках (наприклад, bash) змінна `$?` містить код завершення попередньої команди. У прикладі вище виводиться число `123` - саме те, яке ми передали компілятору 9cc як аргумент. Це означає, що програма працює правильно.

Спробуйте передати інші числа в межах `0–255` (оскільки у Unix коди завершення процесів обмежені цим діапазоном) і переконайтесь, що `9cc` працює як слід у кожному випадку.

### Створення автоматичних тестів

Багато хто з читачів, особливо якщо програмує для себе як хобі, можливо, ніколи не писав тести. Але в цій книзі ми писатимемо тест-код щоразу, коли будемо розширювати компілятор. Спочатку це може здаватися зайвим або нудним, але дуже швидко ви зрозумієте, наскільки це зручно й корисно.

Якщо не писати тести, вам доведеться вручну запускати одні й ті самі перевірки знову й знову після кожної зміни - і це, повірте, набагато виснажливіше та менш надійно.

Багато хто вважає написання тестів нудним саме через ускладнені або надто формалізовані тест-фреймворки. Наприклад, JUnit - потужний інструмент, але його налаштування та вивчення займає час. Тому в цьому розділі ми не використовуватимемо ніяких зовнішніх фреймворків.

Натомість ми написатимемо дуже простий "тестовий фреймворк" на shell-скрипті, яким будемо користуватись протягом розробки.

Нижче наведено приклад shell-скрипта test.sh:

```shell
#!/bin/bash
assert() {
  expected="$1"
  input="$2"

  ./9cc "$input" > tmp.s
  cc -o tmp tmp.s
  ./tmp
  actual="$?"

  if [ "$actual" = "$expected" ]; then
    echo "$input => $actual"
  else
    echo "$input => $expected expected, but got $actual"
    exit 1
  fi
}

assert 0 0
assert 42 42

echo OK
```

Створіть файл **test.sh** з вмістом, наведеним вище, і зробіть його виконуваним за допомогою команди `chmod a+x test.sh`. Спробуйте запустити **test.sh**. Якщо не виникне жодних помилок, скрипт завершиться з відображенням **OK** наприкінці.

```shell
$ ./test.sh
0 => 0
42 => 42
OK
```

Якщо станеться помилка, **test.sh** не відобразить **OK**. Натомість **test.sh** покаже очікуване значення та фактичне значення для невдалого тесту у такому форматі:

```shell
$ ./test.sh
0 => 0
42 expected, but got 123
```

Якщо ви хочете налагодити тестовий скрипт, запустіть його в **bash** з опцією **-x**. З цією опцією **bash** відображатиме трасування виконання, як показано нижче.

```shell
$ bash -x test.sh
+ assert 0 0
+ expected=0
+ input=0
+ cc -o 9cc 9cc.c
+ ./9cc 0
+ cc -o tmp tmp.s
+ ./tmp
+ actual=0
+ '[' 0 '!=' 0 ']'
+ assert 42 42
+ expected=42
+ input=42
+ cc -o 9cc 9cc.c
+ ./9cc 42
+ cc -o tmp tmp.s
+ ./tmp
+ actual=42
+ '[' 42 '!=' 42 ']'
+ echo OK
OK
```

«Тестовий фреймворк», який ми будемо використовувати протягом цієї книги, - це звичайний шелл-скрипт, подібний до наведеного вище. Можливо, цей скрипт здасться надто простим у порівнянні з повноцінними тестовими фреймворками на кшталт JUnit, але така простота добре узгоджується з простотою самого 9cc, тому саме така легкість і є бажаною.

Суть автоматичного тестування полягає в тому, щоб можна було миттєво запустити свій код і автоматично порівняти результат. Тож не варто ускладнювати - головне, почати писати тести.

### Збірка за допомогою make

Протягом читання цієї книги вам доведеться зібрати **9cc** сотні або навіть тисячі разів. Оскільки процес створення виконуваного файлу 9cc і запуску тестового скрипта щоразу однаковий, зручно доручити цю роботу інструменту.

Стандартним інструментом для таких цілей є команда **make**.

Після запуску **make** читає файл з назвою **Makefile** у поточній директорії та виконує команди, записані в ньому.

Makefile складається з **правил**, що закінчуються двокрапкою, і **набору команд**, які виконуються для кожного правила.

Нижченаведений Makefile автоматизує команди, які ми хочемо виконувати на цьому етапі.

```Makefile
CFLAGS=-std=c11 -g -static

9cc: 9cc.c

test: 9cc
        ./test.sh

clean:
        rm -f 9cc *.o *~ tmp*

.PHONY: test clean
```

Створіть **файл з назвою Makefile** в тій самій директорії, де знаходиться **9cc.c**, використовуючи наведений вище вміст.

Після цього, достатньо буде просто виконати команду `make`, щоб зібрати **9cc**, а команду `make test` - щоб запустити тести.

**make** розуміє залежності між файлами, тому після зміни **9cc.c** немає потреби вручну запускати `make` перед `make test`. Якщо виконуваний файл **9cc** старіший за **9cc.c**, `make` автоматично збере **9cc** перед запуском тестів.

`make clean` - це правило для видалення тимчасових файлів. Хоча можна видалити ці файли вручну за допомогою `rm`, це небезпечно, оскільки можна випадково видалити щось важливе. Тому такі службові завдання теж зручно прописати у Makefile.

**Зверніть увагу**: в Makefile для відступів **обов’язково** використовуються **табуляції**, а не пробіли. Використання пробілів (навіть чотирьох або восьми) призведе до помилки. Це незручність пов’язана з тим, що `make` - дуже старий інструмент, розроблений ще в 1970-х роках.

Нарешті, компілятору `cc` **обов’язково** потрібно передавати опцію `-static`. Її призначення буде пояснено в розділі про динамічне лінкування. Наразі вам не потрібно вдаватися в деталі - просто включайте цю опцію завжди.

**Управління версіями за допомогою Git**

У цій книзі ми будемо використовувати **Git** як систему контролю версій. Оскільки компілятор створюється поступово, крок за кроком, створюйте **коміт у Git на кожному етапі** з відповідним **коментарем-коментарем (коміт-меседжем)**.

Коментарі до комітів можна писати **українською або японською** - головне, щоб вони чітко підсумовували зроблені зміни в **одному рядку**. Якщо ви хочете додати детальніше пояснення, зробіть **один порожній рядок після першого рядка**, а потім напишіть розгорнутий опис змін.

За допомогою Git необхідно **відстежувати лише ті файли, які ви створюєте вручну**. Наприклад, **згенеровані файли**, які з’являються після запуску 9cc, **не потрібно додавати в Git**, оскільки їх можна легко згенерувати знову тими ж командами.

Якщо ви включите такі файли до репозиторію, коміти стануть перевантаженими непотрібними змінами. Тому важливо **виключити тимчасові файли та файли резервного копіювання з відстеження Git**.

У Git для цього використовується спеціальний файл з назвою **`.gitignore`**, де ви вказуєте шаблони файлів, які слід ігнорувати.

Створіть файл **.gitignore** у тій самій директорії, де знаходиться **9cc.c**, і додайте до нього такі шаблони, щоб Git ігнорував тимчасові файли, резервні копії редактора тощо:

```
*~
*.o
tmp*
a.out
9cc
```

Якщо ви використовуєте Git вперше, вам потрібно вказати своє ім’я та електронну адресу, щоб Git міг зберігати ці дані в журналі комітів.

Нижче наведено приклад того, як автор налаштовує своє ім’я та email у Git. Замість них введіть свої власні дані:

```
$ git config --global user.name "Rui Ueyama"
$ git config --global user.email "ruiu@cs.stanford.edu"
```

Щоб створити коміт у Git, спочатку потрібно додати змінені файли за допомогою команди git add.

Оскільки цього разу ми створюємо перший коміт, спершу потрібно ініціалізувати Git-репозиторій за допомогою git init, а потім додати всі файли, створені до цього моменту, за допомогою git add.

```shell
$ git init
Initialized empty Git repository in /home/ruiu/9cc
$ git add 9cc.c test.sh Makefile .gitignore
```

Потім зафіксуйте його за допомогою git commit.

```shell
$ git commit -m "Створіть компілятор, який компілює одне ціле число"
```

Укажіть повідомлення коміту за допомогою опції `-m`. Без параметра `-m` **git** запустить редактор. Ви можете підтвердити, що фіксація була успішною, запустивши `git log -p` наступним чином:

```shell
$ git log -p
commit 0942e68a98a048503eadfee46add3b8b9c7ae8b1 (HEAD -> master)
Author: Rui Ueyama <ruiu@cs.stanford.edu>
Date:   Sat Aug 4 23:12:31 2018 +0000

    整数1つをコンパイルするコンパイラを作成

diff --git a/9cc.c b/9cc.c
new file mode 100644
index 0000000..e6e4599
--- /dev/null
+++ b/9cc.c
@@ -0,0 +1,16 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+int main(int argc, char **argv) {
+  if (argc != 2) {
...
```

Нарешті, давайте завантажимо git-репозиторій, який ми створили досі, на GitHub. Немає особливої ​​причини завантажувати на GitHub, але також немає причин не робити цього, і GitHub корисний для резервного копіювання вашого коду. Щоб завантажити на GitHub, створіть нове сховище (у цьому прикладі я створив сховище під назвою 9cc за допомогою користувача rui314) і додайте його як віддалений репозиторій за допомогою такої команди:

```shell
$ git remote add origin git@github.com:rui314/9cc.git
```

Після цього, коли ви виконуєте git push, вміст вашого репозиторію буде відправлено на GitHub. Після виконання `git push` відкрийте GitHub у браузері та переконайтеся, що ваш вихідний код завантажено.

На цьому створення компілятора на першому кроці завершено. Компілятор на цьому етапі є надто простою програмою, щоб її можна було назвати компілятором, але це гарна програма, яка містить усі елементи, необхідні для компілятора. Відтепер ми продовжуватимемо розширювати функції цього компілятора, і, хоча в це все ще важко повірити, ми розробимо з нього чудовий компілятор C. По-перше, насолоджуйтеся завершенням першого кроку.

> **Еталонна реалізація**
>
> [f722daaaae060611](https://github.com/rui314/chibicc/commit/f722daaaae0606115df4ace5a852da23c1a5b0f3)

## Крок 2: Створення компілятора який може додавати та віднімати

На цьому етапі ми розширимо компілятор, створений на попередньому кроці, щоб він міг обробляти не лише значення накшталт `42`, а й вирази, що містять додавання та віднімання, як-от `2+11` чи `5+20-4`.

Вираз накшталт `5+20-4` можна обчислити під час компіляції й вставити в асемблер готове число (в цьому випадку - `21`), але тоді компілятор почне поводитися більше як інтерпретатор. Тому потрібно згенерувати асемблерний код, який виконує додавання та віднімання під час виконання програми. Асемблерні інструкції для додавання та віднімання - це `add` і `sub`. Команда `add` приймає два регістри, додає їхні значення та записує результат у перший регістр. `sub` працює так само, але виконує віднімання. Використовуючи ці інструкції, вираз `5+20-4` можна скомпілювати таким чином:

```asm
.intel_syntax noprefix
.globl main

main:
        mov rax, 5
        add rax, 20
        sub rax, 4
        ret
```

В наведеному вище асемблері спочатку за допомогою команди `mov` у регістр `RAX` записується значення `5`, потім до `RAX` додається `20`, а потім віднімається `4`. На момент виконання команди `ret`, значення в `RAX` має бути `5 + 20 - 4`, тобто `21`.

Спробуймо це перевірити на практиці. Збережемо вищенаведений код у файл із назвою tmp.s, скомпілюємо його та запустимо на виконання.

```shell
$ cc -o tmp tmp.s
$ ./tmp
$ echo $?
21
```

Правильно - як показано вище, якщо все зроблено правильно, то на виході має з’явитися значення 21.

Тепер постає питання: як створити такий асемблерний файл автоматично?

Розглянемо вирази з додаванням та відніманням як мову програмування. Цю мову можна визначити наступним чином:

1. Спочатку йде одне `число`.
2. Далі може йти нуль або більше `термів` (тобто частин виразу).
3. Кожен терм - це або `+` і `число`, або `-` і `число`.

Якщо прямо перекласти це визначення у програму на C, отримаємо такий код (далі, як приклад, буде наведено простий компілятор, що читає такий вираз і генерує відповідний асемблер):

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv) {
  if (argc != 2) {
    fprintf(stderr, "Неправильна кількість аргументів\n");
    return 1;
  }

  char *p = argv[1];

  printf(".intel_syntax noprefix\n");
  printf(".globl main\n");
  printf("main:\n");
  printf("  mov rax, %ld\n", strtol(p, &p, 10));

  while (*p) {
    if (*p == '+') {
      p++;
      printf("  add rax, %ld\n", strtol(p, &p, 10));
      continue;
    }

    if (*p == '-') {
      p++;
      printf("  sub rax, %ld\n", strtol(p, &p, 10));
      continue;
    }

    fprintf(stderr, "Неочікуваний символ: '%c'\n", *p);
    return 1;
  }

  printf("  ret\n");
  return 0;
}
```

Це стало трохи довшою програмою, але початкова частина та рядок із ret залишилися такими ж, як і раніше. В середину було додано код для зчитування термів (тобто додаткових чисел з операціями + або -).

Оскільки тепер програма зчитує не просто одне число, важливо знати, до якого місця в рядку вже було прочитано. Функція `atoi` не повертає інформацію про кількість прочитаних символів, тому, якщо використовувати її, ми не знатимемо, з якого місця починати читати наступний терм.

З цієї причини тут використано функцію `strtol` з C стандартної бібліотеки.

Як працює `strtol`: `strtol` після зчитування числа оновлює вказівник, переданий як другий аргумент, так, щоб він вказував на символ, що йде після числа. Тобто, якщо після числа йде + або -, то вказівник p після виклику `strtol` буде вказувати саме на цей символ.

У наведеній програмі це використовується так:

- Зчитується число за допомогою `strtol`
- Перевіряється, чи далі йдуть символи `+` або `-`
- Якщо так, то в циклі `while` зчитуються наступні терми
- Для кожного терму генерується одна інструкція асемблера

Тепер спробуймо запустити цю оновлену версію компілятора
Після того як ти оновив файл 9cc.c, достатньо просто виконати `make`. Це згенерує новий виконуваний файл 9cc.
Нижче наведено приклад його використання:

```bash
$ make
$ ./9cc '5+20-4'
.intel_syntax noprefix
.globl main
main:
  mov rax, 5
  add rax, 20
  sub rax, 4
  ret
```

Схоже, що асемблер справді правильно генерується — чудова новина!

Тепер, щоб перевірити нову функціональність автоматично, доцільно додати тестовий рядок у файл `test.sh`.

```
assert 21 "5+20-4"
```

Коли ви це зробите, зафіксуйте зміни в git. Для цього виконайте таку команду:
```shell
$ git add test.sh 9cc.c
$ git commit
```

Коли ви виконаєте команду `git commit`, відкриється текстовий редактор. У ньому введіть повідомлення «Додано додавання та віднімання», збережіть файл і закрийте редактор.

Потім скористайтеся командою `git log -p`, щоб переконатися, що коміт було зроблено так, як ви очікували.

Нарешті, виконайте `git push`, щоб відправити коміт на GitHub — після цього цей етап буде завершено!

> **Еталонна реалізація**
>
> [afc9e8f05faddf05](https://github.com/rui314/chibicc/commit/afc9e8f05faddf051aa3a578520d6484ab451282)

## Крок 3: Впровадження токенізатора

У компіляторі, створеному на попередньому кроці, є один недолік - якщо у вхідному рядку містяться пробіли, програма видає помилку. Наприклад, якщо подати рядок із пропусками, як-от `5 - 3`, під час спроби прочитати знак `+` або `-` компілятор натрапить на пробіл і завершить роботу з помилкою.

```shell
$ ./9cc '5 - 3' > tmp.s
Неочікуваний символ: ' '
```

Існує кілька способів вирішення цієї проблеми. Один із очевидних підходів — пропускати пробіли перед тим, як читати символи `+` чи `-`. Цей метод працює і не викликає особливих складнощів, проте на цьому кроці ми розглянемо інший підхід. Цей підхід полягає в тому, щоб до початку обробки виразу розбити вхідний рядок на окремі «слова» (токени) — тобто створити спеціальний токенізатор, який виділяє числа, оператори та інші елементи як окремі одиниці.

Як і в японській чи англійській мовах, арифметичні вирази та мови програмування можна розглядати як послідовність слів. Наприклад, вираз `5+20-4` складається з п’яти «слів»: `5`, `+`, `20`, `-`, `4`. Ці «слова» називають токенами (tokens). Пробіли між токенами існують лише для розділення цих токенів і не є частиною жодного з них. Тому природно під час розбиття рядка на токени ігнорувати пробіли. Процес розбиття рядка на послідовність токенів називають токенізацією (tokenize).

Розбиття рядка на токени має й інші переваги. Під час токенізації можна не лише розділити вхідний рядок на окремі частини, а й класифікувати ці токени, присвоюючи їм типи. Наприклад, символи `+` і `-` однозначно позначають відповідні оператори, а рядок `123` означає число 123. Завдяки такому підходу, коли ми вже маємо типізовані токени, подальша обробка виразу спрощується — менше потрібно думати про те, як інтерпретувати кожен фрагмент під час споживання токенів.

У граматиці для виразів з додаванням і відніманням, які ми розглядаємо, типи токенів можна визначити як три основні категорії: `+`, `-` та `числа`. Для зручності реалізації компілятора також доцільно ввести спеціальний тип токена, який позначатиме кінець послідовності токенів (аналогічно тому, як рядок закінчується символом `'\0'`). Це допоможе зробити код простішим і зручнішим. Токени будемо зв’язувати між собою у вигляді однозв’язного списку, де кожен токен містить посилання на наступний. Завдяки цьому можна обробляти вхід будь-якої довжини, і при цьому легко рухатися по послідовності токенів.

Ось покращена версія компілятора з доданим токенізатором. Програма стала дещо довшою, але тепер вона спочатку розбиває вхідний рядок на токени, які зберігаються у зв’язному списку, і вже потім працює з цією структурою.

```c
#include <ctype.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Типи токенів
typedef enum {
  TK_RESERVED, // Символ
  TK_NUM,      // Токен цілих чисел
  TK_EOF,      // Кінець послідовності даних
} TokenKind;

typedef struct Token Token;

// Тип для токена
struct Token {
  TokenKind kind; // Тип токена
  Token *next;    // Наступний вхідний токен
  int val;        // Якщо тип TK_NUM, то значення
  char *str;      // トークン文字列
};

// Поточний токен
Token *token;

// Функція для повідомлення про помилки.
// Приймає ті самі аргументи, що й printf.
void error(char *fmt, ...) {
  va_list ap;
  va_start(ap, fmt);
  vfprintf(stderr, fmt, ap);
  fprintf(stderr, "\n");
  exit(1);
}

// Якщо наступний токен є очікуваним символом, 
// прочитати один токен і повернути true. В іншому випадку поверніть false.
bool consume(char op) {
  if (token->kind != TK_RESERVED || token->str[0] != op)
    return false;
  token = token->next;
  return true;
}

// Якщо наступний токен є очікуваним символом, читайте один токен вперед.
// В іншому випадку повідомити про помилку.
void expect(char op) {
  if (token->kind != TK_RESERVED || token->str[0] != op)
    error("Очікувався '%c'", op);
  token = token->next;
}

// Якщо наступний токен є числом, просунутися на один токен вперед і повернути це число.
// В іншому випадку повідомити про помилку.
int expect_number() {
  if (token->kind != TK_NUM)
    error("Це не число");
  int val = token->val;
  token = token->next;
  return val;
}

bool at_eof() {
  return token->kind == TK_EOF;
}

// Створіть новий токен і підцепіть його до cur
Token *new_token(TokenKind kind, Token *cur, char *str) {
  Token *tok = calloc(1, sizeof(Token));
  tok->kind = kind;
  tok->str = str;
  cur->next = tok;
  return tok;
}

// Токенізує вхідний рядок p і поверне посилання на перший токен
Token *tokenize(char *p) {
  Token head;
  head.next = NULL;
  Token *cur = &head;

  while (*p) {
    // Пропустити пробіли
    if (isspace(*p)) {
      p++;
      continue;
    }

    if (*p == '+' || *p == '-') {
      cur = new_token(TK_RESERVED, cur, p++);
      continue;
    }

    if (isdigit(*p)) {
      cur = new_token(TK_NUM, cur, p);
      cur->val = strtol(p, &p, 10);
      continue;
    }

    error("Неможливо токенізувати");
  }

  new_token(TK_EOF, cur, p);
  return head.next;
}

int main(int argc, char **argv) {
  if (argc != 2) {
    error("Неправильна кількість аргументів");
    return 1;
  }

  // Токенізуємо
  token = tokenize(argv[1]);

  // Виведіть першу частину ассемблера
  printf(".intel_syntax noprefix\n");
  printf(".globl main\n");
  printf("main:\n");

  // Перша частина виразу має бути числом, тому ми перевіряємо це 
  // та виводимо першу інструкцію mov.
  printf("  mov rax, %d\n", expect_number());

  // Візьміть послідовність токенів `+ <число>` або `- <число>` та виведіть ассемблер.
  while (!at_eof()) {
    if (consume('+')) {
      printf("  add rax, %d\n", expect_number());
      continue;
    }

    expect('-');
    printf("  sub rax, %d\n", expect_number());
  }

  printf("  ret\n");
  return 0;
}
```

Це приблизно 150 рядків коду — не дуже коротко, але й не надто складно. Тут немає жодних хитрощів, тож якщо читати зверху вниз, усе має бути зрозуміло.

Давайте пояснимо кілька прийомів програмування, які використовуються в наведеному вище коді.

- Потік токенів, які зчитує парсер, представлено глобальною змінною `token`. Парсер рухається вперед, переходячи по зв’язному списку токенів. Такий стиль програмування з використанням глобальних змінних може виглядати не надто акуратним. Однак на практиці часто виявляється, що представлення вхідних токенів як потоку (stream), подібно до стандартного введення, робить код парсера більш читабельним. Тому ми застосували саме такий підхід.

- Код, який безпосередньо працює з `token`, винесено у функції `consume` та `expect`, а інші частини програми безпосередньо не торкаються `token`.

- Функція `tokenize` створює зв’язний список токенів. Під час побудови зв’язного списку часто зручно створити «порожній» (dummy) елемент `head`, до якого приєднуються нові елементи, а потім повертати `head->next`. Такий прийом спрощує код. Хоча пам’ять, зайнята самим head, фактично не використовується, вартість виділення локальної змінної практично дорівнює нулю, тому турбуватися про це не варто.

- `calloc` — це функція для виділення пам’яті, схожа на `malloc`. На відміну від `malloc`, `calloc` додатково ініціалізує виділену пам’ять нулями. Тут ми використали `calloc`, щоб не витрачати час на ручне очищення пам’яті.

У цій покращеній версії тепер має бути можливість пропускати пробіли, тому давайте додамо такий однорядковий тест до `test.sh`:

```
assert 41 " 12 + 34 - 5 "
```

Код завершення процесу в Unix — це число від 0 до 255, тому при написанні тестів переконайтеся, що результат всього виразу знаходиться в цьому діапазоні.

Якщо додасте тестові файли до git-репозиторію, цей крок буде вважатися виконаним.

> **Еталонна реалізація**
>
> [ef6d1791eb2a5ef3](https://github.com/rui314/chibicc/commit/ef6d1791eb2a5ef3af913945ca577ea76d4ff97e)

## Крок 4: Покращення повідомлень про помилки

У компіляторі, який ми створили до цього моменту, при наявності синтаксичної помилки можна було лише зрозуміти, що помилка є, але не було зрозуміло, де саме вона сталася. На цьому кроці ми виправимо цю проблему. Зокрема, ми додамо більш інтуїтивні повідомлення про помилки, які будуть показувати конкретне місце помилки та допомагати легше її знайти.

```shell
$ ./9cc "1+3++" > tmp.s
1+3++
    ^ Це не число

$ ./9cc "1 + foo + 5" > tmp.s
1 + foo + 5
    ^ Неможливо токенізувати
```

Щоб показувати такі повідомлення про помилки, потрібно знати, на якому саме байті вхідного рядка сталася помилка. Для цього ми збережемо весь вхідний рядок у змінну `user_input`, а функція виведення помилок буде приймати вказівник на місце у цьому рядку, де сталася помилка.Нижче наведено приклад такої функції:

```c
// Вхідна програма
char *user_input;

// Повідомити про помилку
void error_at(char *loc, char *fmt, ...) {
  va_list ap;
  va_start(ap, fmt);

  int pos = loc - user_input;
  fprintf(stderr, "%s\n", user_input);
  fprintf(stderr, "%*s", pos, " "); // pos пробілів на вхідному рядку
  fprintf(stderr, "^ ");
  vfprintf(stderr, fmt, ap);
  fprintf(stderr, "\n");
  exit(1);
}
```

Функція `error_at` отримує вказівник на позицію в рядку, де сталася помилка. Віднявши від цього вказівника початок рядка (тобто `user_input`), можна визначити, на якому саме байті вхідних даних сталася помилка. Потім цю позицію можна виділити символом `^`, щоб зробити помилку більш помітною.

Якщо зберегти `argv[1]` у змінну `user_input`, а всі виклики помилок оновити з `error("Це не число")` на `error_at(token->str, "Це не число")`, то цей крок вважається завершеним.

У реальних компіляторах також потрібно писати тести на поведінку при помилках введення, але зараз повідомлення про помилки служать лише для допомоги під час налагодження, тому писати тести на них поки що необов’язково.

> **Еталонна реалізація**
>
> [c6ff1d98a1419e69](https://github.com/rui314/chibicc/commit/c6ff1d98a1419e69c31902447e2caa85af4e9844)


> **Колонка: Форматування коду**
> 
> Як і у випадку з текстом японською, де багато помилок у пунктуації роблять його важким для читання, так і у програмному коді — якщо  відступи неправильні або пропуски між словами нестабільні, то навіть без урахування логіки коду його складно назвати акуратним. Форматування коду — це, здавалося б, дрібниця, але застосування чітких правил автоматично допомагає робити код зрозумілішим і приємнішим для читання.
> 
> При розробці в команді важливо домовитися про стиль форматування, але в цій книзі, де ви розробляєте поодинці, можна обрати будь-який популярний стиль, який вам подобається.
>
> У нових мовах програмування часто намагаються зовсім позбавити розробників необхідності сперечатися про стиль, надаючи офіційні інструменти форматування. Наприклад, у мові Go є команда `gofmt`, яка автоматично форматуватиме код за єдиним офіційним стилем. Вона не дає вибору опцій — це єдиний "офіційний формат Go", і це повністю вирішує питання стилю.
>
> Для C і C++ існує `clang-format`, але в цій книзі ми не настільки наполягаємо на використанні подібних інструментів. Головне — намагайтеся писати код з чистим і послідовним стилем одразу, а не виправляти погане форматування потім.

> **Колонка: Уразливість через помилку відступів у коді**
> 
> Іноді неправильні відступи у вихідному коді можуть призводити до серйозних проблем із безпекою. Так сталося, зокрема, у iOS та macOS, де через таку помилку виникла критична вразливість.
> 
> Нижче наведено фрагмент коду, де була допущена ця помилка:
> ```c
> if ((err = ReadyHash(&SSLHashSHA1, &hashCtx)) != 0)
>     goto fail;
> if ((err = SSLHashSHA1.update(&hashCtx, &clientRandom)) != 0)
>     goto fail;
> if ((err = SSLHashSHA1.update(&hashCtx, &serverRandom)) != 0)
>     goto fail;
> if ((err = SSLHashSHA1.update(&hashCtx, &signedParams)) != 0)
>     goto fail;
>     goto fail;
> if ((err = SSLHashSHA1.final(&hashCtx, &hashOut)) != 0)
>     goto fail;
> ```
> Чи помітили ви, де тут помилка? З першого погляду цей код виглядає звичайним, але якщо придивитись уважніше, то другий знизу оператор `goto` не входить до тіла `if` і тому виконується завжди.
> 
> На жаль, цей код відповідав за перевірку TLS-сертифікатів, і через цю помилку більша частина коду перевірки сертифіката просто пропускалася за допомогою безумовного переходу `goto`. В результаті iOS і macOS приймали недійсні сертифікати за дійсні, що дозволяло проводити атаку типу "людина посередині" (MITM) на HTTPS-сайти.
> 
> Цю помилку виявили і виправили у 2014 році. Через повторення слова `goto fail` її назвали «помилкою goto fail» — своєрідна гра слів, бо через зайвий `goto fail` програма фактично "провалювалася".

## Опис граматики та рекурсивний спусковий розбір

Отже, далі ми хочемо додати до мови множення, ділення та дужки для керування пріоритетом операцій — тобто `*`, `/`, `()`. Але для цього постає одна велика технічна проблема: множення і ділення повинні обчислюватися раніше, ніж додавання чи віднімання. Наприклад, вираз `1 + 2 * 3` повинен інтерпретуватись як `1 + (2 * 3)`, а не як `(1 + 2) * 3`.

Такі правила, що визначають, які оператори «зчіплюються» першими, називаються пріоритетом операторів (operator precedence).

Як же обробляти пріоритет операторів?
У компіляторі, який ми створювали до цього моменту, ми просто послідовно читаємо вхідні токени з початку і одразу генеруємо асемблер. Якщо ми просто розширимо його підтримкою `*` та `/`, то вираз `1 + 2 * 3` буде оброблений як `(1 + 2) * 3`, що неправильно.

Звісно, справжні компілятори можуть коректно обробляти пріоритети операторів. Синтаксичний аналіз компілятора (парсинг) — це потужна технологія, яка дозволяє правильно інтерпретувати навіть дуже складний код, якщо він відповідає граматиці.
Іноді поведінка компілятора здається майже надлюдською, але насправді комп’ютер не має людської здатності розуміти мову — весь синтаксичний аналіз здійснюється за допомогою чітких, механічних алгоритмів.

Тож як саме це працює?

У цьому розділі ми зробимо паузу від кодування і вивчимо техніки синтаксичного аналізу. Ми розглянемо ці техніки у такому порядку:

1. Зрозуміємо, яку структуру даних має повертати парсер — тобто, яка кінцева мета аналізу.
2. Вивчимо правила визначення граматики — як описуються синтаксичні конструкції.
3. На основі цих правил — навчимося писати парсер за допомогою техніки рекурсивного спуску.

### Представлення граматичної структури за допомогою деревоподібної структури

При реалізації парсерів для мов програмування типовим є такий підхід: вхідними даними є плоска послідовність токенів, а вихід — дерево, яке відображає вкладену (ієрархічну) структуру. Компілятор, який ми створюємо в цій книзі, також дотримується цього підходу.

У мовах програмування на зразок C синтаксичні конструкції на кшталт if або while можуть бути вкладеними одна в одну. Використання дерев для їхнього представлення — цілком природне й наочне рішення.

Арифметичні вирази також мають внутрішню структуру: наприклад, вирази в дужках обчислюються першими, а множення й ділення мають вищий пріоритет, ніж додавання й віднімання. На перший погляд, така структура може не виглядати деревоподібною, але насправді дерево чудово й наочно передає ці відносини.

Наприклад, вираз 1 * (2 + 3) можна зобразити у вигляді такого дерева:

![Дерево, яке представляє 1*(2+3)](/img/chibicc/01_expr_tree.svg)

Дерево, яке представляє `1*(2+3)`

Якщо ми приймаємо правило, за яким обчислення відбувається від листків дерева до кореня, тоді наведене вище дерево чітко виражає зміст виразу `1 * (2 + 3)` як: спочатку обчислити `2 + 3`, а потім помножити результат на `1`. Іншими словами, порядок обчислення прямо закладений у структурі самого дерева.

Розглянемо ще один приклад. Наступне дерево відповідає виразу `7 - 3 - 3`:

![Дерево, яке представляє 7-3-3](/img/chibicc/02_expr_tree.svg)

Дерево, яке представляє `7-3-3`

У наведеному вище дереві правило "обчислювати зліва направо" для віднімання чітко зафіксоване у самій формі дерева. Воно представляє вираз `(7 - 3) - 3 = 1`, а не `7 - (3 - 3) = 7`.

Якщо б ми мали на увазі останній випадок (тобто обчислення праворуч спочатку), дерево було б глибшим з правого боку. 
Таким чином, структура дерева точно відображає асоціативність оператора, тобто порядок, у якому виконуються однакові операції.
Оператори, які обчислюються зліва направо, називаються лівозв’язними (left-associative).
Оператори, що обчислюються справа наліво, називаються правозв’язними (right-associative).

У мові C, майже всі оператори (за винятком операції присвоєння =) є лівозв’язними.

Дерева дуже добре масштабуються: їх можна зробити скільки завгодно глибокими, щоб виразити довгі вирази. Розглянемо приклад виразу `1 * 2 + 3 * 4 * 5`, який можна представити наступним деревом:

![Дерево, яке представляє 1 * 2 + 3 * 4 * 5](/img/chibicc/03_expr_tree.svg)

Дерево, яке представляє `1 * 2 + 3 * 4 * 5`

Таке дерево, як наведене вище, називається синтаксичним деревом (syntax tree).
Особливо, якщо з дерева видалено зайві елементи на кшталт дужок, які потрібні лише для групування в тексті, і воно виражає тільки суттєву структуру виразу, таке дерево називається абстрактним синтаксичним деревом (abstract syntax tree, AST). Усі приклади, які ми розглядали раніше, — це саме абстрактні синтаксичні дерева.

AST — це внутрішнє представлення програми в компіляторі, і тому його структура може бути вільно визначена з міркувань зручності реалізації.
Проте є деякі природні відповідності:
Арифметичні оператори, як-от додавання чи множення, є бінарними (мають лівий і правий операнд), тому у більшості компіляторів вони представляються як двійкові дерева.
Функції або блоки коду, де послідовно виконується багато інструкцій, зазвичай представляються як дерева з довільною кількістю дочірніх вузлів — «плоскі» структури, де послідовність має значення.

Головна мета синтаксичного аналізу — побудова абстрактного синтаксичного дерева (AST).
Компілятор спочатку виконує синтаксичний аналіз, щоб перетворити вхідну послідовність токенів на AST.
Потім це дерево слугує основою для наступного етапу — генерації асемблерного коду або іншої форми виконуваного представлення.

### Визначення граматики за допомогою правил породження

Тепер давайте дізнаємося, як описуються синтаксичні правила мов програмування.
Більшість граматик мов програмування визначається за допомогою правил породження (production rules).
Правила породження — це спосіб рекурсивного визначення граматики.

Спробуємо спочатку подивитися на це з точки зору природної мови.
У українській мові, як і в багатьох інших, граматичні конструкції мають вкладену (ієрархічну) структуру.
Наприклад, у реченні "Квітка гарна":

Слово "квітка" — іменник.
Його можна розширити до "червона квітка" — іменна фраза.
Ще далі: "трохи червона квітка".
І навіть вставити все це в інше речення:
"Я подумав, що трохи червона квітка гарна".

Таку структуру можна формалізувати як набір граматичних правил:
"Речення" складається з "підмета" і "присудка". "Іменна фраза" — це або іменник, або прикметник + іменна фраза.
Починаючи з початкового символу ("речення"), ми можемо за цими правилами поступово розгортати конструкцію, створюючи нескінченну кількість граматично правильних речень.

А ще — у зворотному напрямку — ми можемо взяти готове речення і, аналізуючи його за цими правилами, з’ясувати його структуру.
Цей процес і є суттю синтаксичного аналізу (парсингу).

Спочатку такі правила породження були розроблені для природних мов,
але вони виявилися дуже сумісними з обробкою даних у комп’ютерах.
Тому сьогодні широко використовуються у мовах програмування, компіляторах, інтерпретаторах та багатьох інших галузях інформатики.

> **Колонка: Генеративна граматика Чомського**
> 
> Ідею генеративної граматики (тобто граматики на основі правил породження) вперше запропонував лінгвіст Ноам Чомскі.
> Його ідеї мали величезний вплив як на лінгвістику, так і на комп’ютерні науки.

> Згідно з гіпотезою Чомського, люди здатні говорити тому, що в мозку людини вроджено існує спеціальний механізм, який дозволяє засвоювати правила породження мови.
> Іншими словами, люди мають природжену здатність до опанування рекурсивних граматичних структур, що й дає змогу оволодівати мовою.
> Інші тварини, за Чомським, не здатні до мовлення саме тому, що в їхньому мозку відсутній такий механізм.
> Він припустив, що ця здатність — унікальна для виду Homo sapiens.
> Минуло вже майже 60 років від моменту, коли Чомскі оприлюднив цю гіпотезу.
> Хоча її не вдалося ні остаточно довести, ні спростувати, вона і сьогодні залишається впливовою та переконливою концепцією в лінгвістиці та когнітивних науках.

### Опис правил породження за допомогою BNF

Існує одна нотація для компактного і зрозумілого опису правил породження — це BNF (Backus–Naur form) і її розширення EBNF (Extended BNF). У цій книзі граматику мови C пояснюватимемо за допомогою EBNF. У цьому розділі спочатку буде пояснено BNF, а потім — розширення EBNF.

У BNF кожне правило породження записується у вигляді A = α₁α₂⋯. Це означає, що символ A можна розкласти у послідовність α₁α₂⋯. Послідовність α₁α₂⋯ складається з нуля або більше символів, які можуть бути як символами, що не підлягають подальшому розкладу, так і символами, які можуть бути далі розкладені (тобто зустрічаються зліва у деяких правилах породження).

Символи, які не підлягають подальшому розкладу, називають «термінальними символами» (terminal symbol), а символи, які з’являються зліва у правилах і можуть розкладатися — «нетермінальними символами» (nonterminal symbol). Граматику, визначену такими правилами, зазвичай називають «контекстно-вільною граматикою» (context free grammar).

Один нетермінальний символ може відповідати декільком правилам породження. Наприклад, якщо є правила A = α₁ і A = α₂, це означає, що A може бути розкладений або в α₁, або в α₂.

Праворуч від знака рівності може бути порожньо. У такому випадку символ зліва розкладається в порожню послідовність (тобто в нічого). Але для зручності сприйняття замість пропуску правої частини зазвичай пишуть символ ε (епсилон), що означає «нічого». Ця нотація використовується і в цій книзі.

Рядки беруться у подвійні лапки, наприклад "foo". Рядки завжди є термінальними символами.

Ось основні правила BNF. У EBNF до них додаються ще такі символи, які дозволяють коротко і зручно описувати складніші правила.

| Форма запису | Значення |
| - | - |
| `A*` | `A` повторюється 0 або більше разів | 
| `А?` | `A` або `ε` | 
| `A \| B` | `A` або `B` | 
| `( ... )` | Групування | 

Наприклад, `A = ("fizz" | "buzz")*` означає, що `A` є рядком, який містить 0 або більше випадків `"fizz"` або `"buzz"`; тобто,

- ""
- "fizz"
- "buzz"
- "fizzfizz"
- "fizzbuzz"
- "buzzfizz"
- "buzzbuzz"
- "fizzfizzfizz"
- "fizzfizzbuzz"
- ⋯⋯

і це можна розширити до списка будь-якої довжини

> **Колонка: BNF і EBNF**
> 
> У звичайній BNF (тобто без розширення Extended) немає таких зручних скорочених записів, як *, ?, |, або ( ... ). Проте, множина речень, які можна згенерувати за допомогою BNF, є такою ж, як і в EBNF. Це можливо тому, що конструкції EBNF можна переписати у вигляді BNF, як показано нижче:
> 
> | EBNF	| Відповідна форма у BNF|
> | - | - | 
> | `A = α*`	| `A = αA` та `A = ε` |
> | `A = α?`	| `A = α` та `A = ε` |
> | `A = α \| β`	| `A = α` та `A = β` |
> | `A = α (β₁β₂⋯) γ`	| `A = α B γ` та `B = β₁β₂⋯` |
> 
> Наприклад, щоб згенерувати рядок ααα з правила `A = αA` та `A = ε`, розгортання виглядатиме так:
> `A → αA → ααA → αααA → ααα`
> 
> Як видно, записи `*` і `?` є лише зручними скороченнями, але завдяки їм запис > граматики стає значно зрозумілішим і компактнішим. Саме тому, коли є можливість, зазвичай використовують саме скорочену нотацію.

### Прості правила породження

Як приклад опису граматики за допомогою EBNF, розглянемо наступні правила породження:

```
expr = num ("+" num | "-" num)*
```

num вважається попередньо визначеним символом, що позначає числове значення.

У цій граматиці `expr` (вираз) означає: спочатку йде один `num`, за яким може йти нуль або більше послідовностей типу: `"+"` і `num`, або `"-"` і `num`.

Це правило фактично описує граматику арифметичних виразів з додаванням і відніманням.

Починаючи з `expr`, можна створити будь-який рядок, що складається з додавання або віднімання чисел — наприклад: `1`, `10 + 5`, `42 - 30 + 2`

Перевіримо результати розгортання:

```
expr → num → "1"
```
```
expr → num "+" num
     → "10" "+" "5"
```
```
expr → num "-" num "+" num
     → "42" "-" "30" "+" "2"
```

Порядок такого розгортання можна не лише показати послідовно за допомогою стрілок, а й представити у вигляді дерева розбору (синтаксичного дерева).

![Синтаксичне дерево для 1](/img/chibicc/04_ast_tree.svg)

Синтаксичне дерево для `1`

![Синтаксичне дерево для 10+5](/img/chibicc/05_ast_tree.svg)

Синтаксичне дерево для `10+5`

![Синтаксичне дерево для 42-30+2](/img/chibicc/06_ast_tree.svg)

Синтаксичне дерево для `42-30+2`

Представлення у вигляді дерева дає змогу легко зрозуміти, який нетермінальний символ розгортається в які саме символи.

Синтаксичне дерево, подібне до наведеного вище, яке містить усі токени з вхідного рядка та повністю відповідає граматичним правилам один до одного, часто називають конкретним синтаксичним деревом (concrete syntax tree).
Цей термін зазвичай використовують, коли хочуть протиставити його абстрактному синтаксичному дереву (abstract syntax tree).

У конкретному синтаксичному дереві, наведеному вище, правило обчислення додавання та віднімання зліва направо не відображене у самій структурі дерева.

Таке правило не задається за допомогою EBNF, а зазвичай вказується окремо у текстовому описі мови, наприклад: «Операції додавання та віднімання виконуються зліва направо».
Під час розбору (парсингу) парсер враховує як граматику EBNF, так і ці додаткові зауваження зі специфікації мови.
На основі цього він будує абстрактне синтаксичне дерево (AST), яке правильно відображає порядок обчислення виразу.

Таким чином, структура конкретного синтаксичного дерева (CST), отриманого за EBNF, і абстрактного синтаксичного дерева (AST), що відображає семантику виконання, не повністю збігаються.

Отже, у наведеній вище граматиці форма конкретного синтаксичного дерева (CST), яке відповідає EBNF, лише загалом збігається з формою абстрактного синтаксичного дерева (AST), яке будує парсер. Можна визначити граматику так, щоб структура абстрактного та конкретного дерева максимально збігалася, але це зробить граматику надмірно складною та громіздкою, і, як наслідок, ускладнить розробку парсера.
Наведена граматика — це приклад вираження, що досягає балансу між строгою формалізацією (через EBNF) та зрозумілими уточненнями у природній мові. Такий підхід робить граматику зручною та практичною для використання як у документації, так і в реалізації.

### Вираження пріоритету операторів за допомогою правил породженння

Правила породження — це дуже потужний інструмент для опису граматики. Якщо граматику правильно побудувати, то пріоритет операторів також можна виразити всередині правил породження. Нижче наведено таку граматику.

```
expr = mul ("+" mul | "-" mul)*
mul  = num ("*" num | "/" num)*
```

Раніше правило передбачало, що `expr` безпосередньо розгортається в `num`, а тепер `expr` розгортається через `mul` до `num`. `mul` — це правило продукції для множення і ділення, а `expr`, яке виконує додавання і віднімання, використовує `mul` як свого роду складову частину. У цій граматиці правило, що множення і ділення виконуються раніше, природним чином відображається у синтаксичному дереві. Давайте розглянемо декілька прикладів.

![Синтаксичне дерево для 1*2+3](/img/chibicc/07_ast_tree.svg)

Синтаксичне дерево для `1*2+3`

![Синтаксичне дерево для 1+2*3](/img/chibicc/08_ast_tree.svg)

Синтаксичне дерево для `1+2*3`

![Синтаксичне дерево для 1*2+3*4*5](/img/chibicc/09_ast_tree.svg)

Синтаксичне дерево для `1*2+3*4*5`

У наведеній вище деревоподібній структурі множення завжди з’являється ближче до листків дерева, ніж додавання. Насправді, оскільки немає правила повернення від `mul` до `expr`, неможливо побудувати дерево, де під множенням було б додавання. Проте те, що такі прості правила дозволяють чітко відобразити пріоритет операторів у вигляді структури дерева, здається досить цікавим. Запрошую читачів самостійно зіставити правила продукції та синтаксичні дерева, щоб переконатися в правильності побудови дерева.


### Правила породженння із рекурсією

У генеративній граматиці можна звичайно записувати рекурсивні граматики. Нижче наведені правила породження граматики, яка додає пріоритет дужок до арифметичних операцій.

```
expr    = mul ("+" mul | "-" mul)*
mul     = primary ("*" primary | "/" primary)*
primary = num | "(" expr ")"
```

Якщо порівняти цю граматику з попередньою, то там, де раніше дозволявся лише `num`, тепер може з’являтися `primary`, тобто `num` або `"(" expr ")"`. Іншими словами, у цій новій граматиці вираз у круглих дужках обробляється так само, як і окреме число. Давайте подивимось на приклад.

Наступне дерево є синтаксичним деревом для виразу `1*2`.

![Синтаксичне дерево для 1*2](/img/chibicc/10_ast_tree.svg)

Синтаксичне дерево для `1*2`

![Синтаксичне дерево для 1*(2+3)](/img/chibicc/11_ast_tree.svg)

Синтаксичне дерево для `1*(2+3)`

Якщо порівняти два дерева, видно, що відрізняється лише розгортка правої гілки `mul` у вигляді `primary`. Правило, яке дозволяє `primary` в кінцевому результаті розгортатися або в одне число, або в будь-який вираз, взятий у дужки, чітко відображається у структурі дерева. Те, що пріоритет дужок можна обробляти за допомогою таких простих правил породження, є досить вражаючим, чи не так?

### Сінтаксічний аналіз через рекурсивний спуск

Якщо задані правила породження для мови C, то за їх допомогою можна послідовно розгортати і механічно генерувати будь-яку правильну програму на C з точки зору цих правил. Проте в 9cc ми хочемо зробити навпаки. Нам подається програма на C у вигляді рядка, і ми хочемо дізнатися структуру синтаксичного дерева — тобто порядок розгортання, який дасть у результаті саме цей вхідний рядок.

Насправді для певних типів правил породження, якщо правило задано, можна автоматично написати код, який знаходить синтаксичне дерево, що відповідає реченню, згенерованому цим правилом. Метод, який ми тут описуємо — «сінтаксічний аналіз через рекурсивний спуск» — є одним із таких прийомів.

Як приклад, розглянемо граматику для арифметичних операцій. Повторно наведемо граматику для арифметичних операцій.

```
expr    = mul ("+" mul | "-" mul)*
mul     = primary ("*" primary | "/" primary)*
primary = num | "(" expr ")"
```

Основна стратегія написання парсера за допомогою рекурсивного спуску полягає в тому, щоб кожен нетермінал безпосередньо відобразити у відповідну функцію. Таким чином, парсер матиме три функції: `expr`, `mul` і `primary`. Кожна з цих функцій розбирає послідовність токенів відповідно до свого імені.

Розглянемо це конкретно на коді. Вхідними даними для парсера є послідовність токенів. Оскільки парсер повинен повернути абстрактне синтаксичне дерево, визначимо тип вузла абстрактного синтаксичного дерева. Нижче наведено визначення типу вузла.

```c
// Типи вузлів у абстрактному синтаксичному дереві
typedef enum {
  ND_ADD, // +
  ND_SUB, // -
  ND_MUL, // *
  ND_DIV, // /
  ND_NUM, // Ціле число
} NodeKind;

typedef struct Node Node;

// Вузел у абстрактному синтаксичному дереві
struct Node {
  NodeKind kind; // Тип вузла
  Node *lhs;     // Ліви частина дерева
  Node *rhs;     // Права частина дерева
  int val;       // Використовується якщо kind дорівнює ND_NUM
};
```
`lhs` і `rhs` означають ліву сторону (left-hand side) та праву сторону(right hand side) відповідно.

Ми також визначаємо функцію для створення нового вузла. У цій граматиці є два типи арифметичних операцій: двійкові оператори, які беруть ліву та праву частини, і числа, тому ми готуємо дві функції, які відповідають цим двом типам.

```c
Node *new_node(NodeKind kind, Node *lhs, Node *rhs) {
  Node *node = calloc(1, sizeof(Node));
  node->kind = kind;
  node->lhs = lhs;
  node->rhs = rhs;
  return node;
}

Node *new_node_num(int val) {
  Node *node = calloc(1, sizeof(Node));
  node->kind = ND_NUM;
  node->val = val;
  return node;
}
```

Отже, використовуючи ці функції та типи даних, давайте напишемо парсер. Оператори `+` та `-` вважаються лівоасоціативними. Функція, яка розбирає лівоасоціативні оператори, зазвичай має такий шаблон:

```c
Node *expr() {
  Node *node = mul();

  for (;;) {
    if (consume('+'))
      node = new_node(ND_ADD, node, mul());
    else if (consume('-'))
      node = new_node(ND_SUB, node, mul());
    else
      return node;
  }
}
```

Функція `consume` — це функція, визначена раніше, яка, якщо наступний токен у вхідному потоці співпадає з аргументом, просуває потік на один токен вперед і повертає true.

Ретельно прочитайте функцію `expr`. Ви побачите, що правило продукції `expr = mul ("+" mul | "-" mul)*` безпосередньо відображається у виклики функцій і цикл. Абстрактне синтаксичне дерево, яке повертає функція `expr`, будується так, що оператори є лівоасоціативними — гілка зліва у вузлі глибша.

Тепер давайте визначимо функцію `mul`, яку використовує `expr`. Оператор `*` та `/` також є лівоасоціативними, тому їх можна описати за тією ж схемою. Наводжу визначення цієї функції нижче.

```c
Node *mul() {
  Node *node = primary();

  for (;;) {
    if (consume('*'))
      node = new_node(ND_MUL, node, primary());
    else if (consume('/'))
      node = new_node(ND_DIV, node, primary());
    else
      return node;
  }
}
```

Виклики функцій у наведеному вище коді безпосередньо відповідають правилу породження `mul = primary ("" primary | "/" primary)`.

Нарешті, визначимо функцію `primary`. Оскільки `primary` не розбирає лівоасоціативні оператори, її код не відповідає шаблону, описаному раніше. Однак, якщо безпосередньо відобразити правило продукції `primary = "(" expr ")" | num` у виклики функцій, то функція `primary` може бути записана так:

```c
Node *primary() {
  // Якщо наступним маркером є "(", це має бути "(" expr ")".
  if (consume('(')) {
    Node *node = expr();
    expect(')');
    return node;
  }

  // В іншому випадку це має бути число.
  return new_node_num(expect_number());
}
```

Отже, тепер у нас є всі необхідні функції, але чи справді вони можуть розібрати послідовність токенів? На перший погляд це може здатися незрозумілим, проте з їх допомогою можна коректно розпарсити послідовність токенів. Розглянемо приклад виразу `1+2*3`.

Спочатку викликається функція `expr`. Ми вважаємо, що весь вираз — це `expr` (у нашому випадку це так), і починаємо читати вхід. Далі відбуваються послідовні виклики `expr → mul → primary`, завдяки чому зчитується токен `1`, і функція `expr` повертає синтаксичне дерево, що відповідає числу `1`.

Далі у функції `expr` вираз `consume('+')` повертає `true`, тому токен «+» споживається, і знову викликається функція `mul`. На цьому етапі у вхідному потоці залишився рядок `2*3`.

З `mul`, як і раніше, викликається функція `primary`, яка зчитує токен `2`, але цього разу `mul` не повертається одразу. Оскільки вираз `consume('*')` в `mul` також повертає `true`, `mul` знову викликає `primary`, яка зчитує токен `3`. У результаті функція `mul` повертає синтаксичне дерево, що представляє вираз `2*3`.

Після повернення у функцію `expr`, синтаксичні дерева для `1` та для `2*3` поєднуються, формуючи дерево для виразу `1+2*3`, яке і стає результатом функції `expr`. Отже, вираз `1+2*3` було правильно розпарсено.

Якщо подати виклики функцій і токени, які вони зчитують, у вигляді схеми, вона виглядає приблизно так. На нижній діаграмі є рівень `expr`, що відповідає всьому виразу `1+2*3` — це виклик `expr`, який розбирає весь вхід. Над ним розташовані два виклики `mul`, які відповідають розбору частин `1` та `2*3` відповідно.

![Відносини викликів функцій під час розбору 1+2*3](/img/chibicc/12_function_call.svg)

Відносини викликів функцій під час розбору `1*(2+3)`

Нижче наведено трохи складніший приклад. Наведена діаграма показує взаємозв’язок викликів функцій під час розбору виразу `1*2+(3+4)`.

![Відносини викликів функцій під час розбору 1*2+(3+4)](/img/chibicc/13_function_call.svg)

Відносини викликів функцій під час розбору `1*2+(3+4)`

Для програмістів, які не звикли до рекурсії, такі рекурсивні функції, як наведені вище, можуть здаватися складними для розуміння. Чесно кажучи, навіть автор, який добре знайомий із рекурсією, іноді сприймає подібний код майже як магію. Рекурсивний код, навіть коли його принципи зрозумілі, все одно викликає певне відчуття загадковості — мабуть, це просто така його природа. Тож радимо кілька разів уважно прогнати код у голові, щоб переконатися, що він дійсно працює.

Метод синтаксичного аналізу, при якому одне правило породження відображається в одну функцію, називається синтаксичним аналізом із рекурсивним спускомі (recursive descent parsing). У наведеному парсері для прийняття рішення про виклик функції або повернення використовується перегляд лише одного токена вперед, такий парсер називають LL(1)-парсером. А граматики, які можна розпарсити LL(1)-парсером, називають LL(1)-граматиками.


